js warts
negative index : like 0 or count from the end of the array/string?
	inconsistant (indexOf and substring vs slice and substr)

objects used as dictionary (no length, perfs, limited keys)

???
Symbol "The symbol type is used to create unique identifiers for objects"
	https://javascript.info/types
Symbol as key
	"Bear in mind that enumerable properties are looped over by for...in loops, with the exception of Symbols. " https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable
enumerable (and own) object
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable
get/set
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set
	(+ impact on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign : "Therefore it assigns properties, versus copying or defining new properties. This may make it unsuitable for merging new properties into a prototype if the merge sources contain getters. ")
weird comparison rules
	https://javascript.info/comparison
generator
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*


standard
last published:
https://www.ecma-international.org/publications/standards/Ecma-262.htm
includes proposals:
https://tc39.es/ecma262/
https://github.com/tc39/proposals
unit test: mocha, jest

courses:
https://javascript.info/
https://developer.mozilla.org/en-US/docs/Web/JavaScript
https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/#basic-javascript
codeacademy
https://www.theodinproject.com/paths/foundations/courses/foundations
udemy
	ES2015	https://www.udemy.com/course/the-advanced-web-developer-bootcamp/
	ES6		https://www.udemy.com/course/modern-javascript-es6-for-react-js/
nodeschool

todo
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode


npm
npm install
-g
	install globally
-D
	devDependency (develop/stest)

npm init
	create project
-y --yes
	defaults, do not prompt questions

babel
	transpiler : convert modern js into js that can be run on older js engines
	to be combined with a polyfill

"use strict";
Introduced in EC5 (2009), backward incompatible changes
at beginning of script
at beginning of function
??? automatically enabled by modules and classes?

;
always ; recommended


==
	does type conversion
	if number + a string/boolean => the string/boolean converted to number
===
	no type conversion
	different type => different

Object.is(a, b)
	like === but
	NaN is NaN
	+0 is not -0
	

primitive types (singlue value, stored as value in variables)
string
number
bigint
boolean
symbol
null
undefined

Object type
	{}
	function
	array
	Map
	...

String, Number, Boolean, Symbol
	allow calling methods on primitive types
	eg aString.toUpperCase(), aNumber.toFixed(2)
	as if the js Engine created a temporary object wrapper around the primitive to allow an operation to carry out.

new Number(0)
new Boolean(false)
	create a wrapper object
	NEVER USE !!!
	awful:
		typeof is object
		considered truthy (like all objects)!!
			if(new Boolean(false)) console.log("this will print!")
			if(new Number(0)) console.log("this will print!")
	Number("123") ok : returns primitive

typeof
	return string of the type

true/false	'boolean'
null		'object'	!
[]			'object'	!
{}			'object'
function() {}	'function'
() => none	'function'
class Foo{}	'function'
1			'number'
1n			'bigint'
Symbol("a")	'symbol


null
	no value, unknown, empty
	x = null; makes sense
	Number(null) === 0

undefined
	value not assigned
	x = undefined; to avoid
	Number(undefined) === NaN

null == undefined
	this is a special rule
	(eg. [] != {})



--- Number ---
numbers are double
0.1 + 0.2 == 0.30000000000000004
Number.MIN_SAFE_INTEGER
Number.MAX_SAFE_INTEGER
	around 10**15, 2^53-1
	Number.MAX_SAFE_INTEGER +1 === Number.MAX_SAFE_INTEGER + 2

1_000_000_000
1e3 === 1000
1e2 === 100
1e1 === 10
1e0 === 1
1e-1=== 0.1

0xff
	hexa

0b01111111
	binary


0o10
	octal

010	
use strict : 	 error
non use strict : === 8, but Number("010") === 10

Number(<something>)
+a_string
	convert to number (eg. a string)

parseInt(str)
parseInt(str, radix) // default 10
parseFloat(str)
	convert to number
	ignore non-number text at the end of the string
	Number("123x") === NaN
	parseInt("123x") === 123

Infinity
	obtained with the keyword or dividing by zero (except 0/0, Infinity/Infinity,..)
	
Nan
	cannot parse a number ParseInt(), Number()
	string + operation "foo" / 2


aNumber.toString()
aNumber.toString(2) // base

2.toString() // error
(2).toString() 2..toString() // ok


BigInt
	represents integer of any size
	! fairly recent (Safari 2020)
	BigInt(1)
	BigInt("1")
	1n 				// BigInt literal
	BigInt(1) + 1	// NO
	BigInt(1) == 1	// yes (also <, <=,...)
	BigInt(1) === 1 // false
	
	can use * + / ...
	/ rounds toward zero
	cannot use with Math.xxx



bitwise operators
AND ( & )
OR ( | )
XOR ( ^ )
NOT ( ~ )
LEFT SHIFT ( << )
RIGHT SHIFT ( >> )
ZERO-FILL RIGHT SHIFT ( >>> )
numbers are converted to signed 32 bits integers. Truncated if needed


logical operators
|| && ! ??
	if operand is not a boolean
		convert to boolean to evaluate if true/false
		if operand is returned (see below): returns the original value (not converted)
|| || || ...
	return first true value
	or last value
&& && && ...
	return first false value
	or first value

a ?? b
	nullish coalescing operator
	nullish = null or undefined ( https://developer.mozilla.org/en-US/docs/Glossary/Nullish )
	if a not null or undefined: returns a
	if a null or undefined: 	returns b
	fairly new (2020)
	useful to give a default value if something may not be defined
		alert(user ?? "Anonymous");

a?.b
	optional chaining
	the object on the left may not exist
	if a is nullish (null/undefined) return undefined
	if a exists returns value of b (which can be undefined)
	permits: a?.b?.c
	a && a.b && a.b.c is similar but
		more verbose
		if falsish value : return falsish value instead of undefined
	the variable a must exist (but may be null/undefined) otherwhise exception
object.function?.()
	calls the function if it exists
	returns undefined if it does not exist
object?.[key]
array?.[i]
	read if object/array exists, otherwise returns undefined
delete obj?.value
	delete obj.value if obj exists
a_null_variable?.name = "John";
	SyntaxError (cannot do what amounts to undefined = "x");




--- String ---

"13"[0] === "1"
"13".charAt(0) === "1"		// was the only way originally
"hell".length === 4

"ba" < "bar"
	lexicographical order
	uppercase before lowercase  (cf ASCII table)
	diacritical marks after non diacritical marks (z < รถ) (cf unicode)
	str.localeCompare to be language aware

`template literal ${expression}`
	${} = literal
`multi
	line`
	multiline (return and newline part of the string)

a_function`tagged template literal`
	call a_function passing the strings and ${} to it
foo`tagged ${"hi"}template literal ${1+1} hi`
same as : foo([ 'tagged ', 'template literal ', ' hi' ], 'hi', 2)

String(something)
	convert to string

str.localeCompare(otherString)
	compare with locale awareness. Eg. ร < P

str.toUpperCase()

str.indexOf(searchedString, fromIndex)
	returns index
	-1 if not found
	! careful:  if(str.indexOf(...)) <== wrong (fails on -1, 0) use includes instead
	negative index like 0

str.includes(searchedString, fromIndex)
	returns true/false


"oh hello".substring(3, 7)
	returns substring
	from, to (excluded)
	can ommit to
	negative index like 0
	if from > to => swaps index

str.slice(startI, endI)
	modern version of substring.
	similar:
	returns substring
	endI excluded
	can ommit endI
	different:
	negative index counts from end of string (-1 = last index)
	if start > end => empty

str.substr(startI, length)
	negative index counts from end of string (-1 = last index)

str.split(', ')
	turn string into array based on the delimiter


--- Symbol ---
Unique identifier
NOT like string
NOT like smalltalk's #symbol


Symbol("a") != Symbol("a")
	each symbol is unique
	even if same description
	(exception see global registry Symbol.for)

alert(Symbol("hi"))
"My symbol is " + Symbol("hi")
	TypeError, symbols do not auto convert to string

Usage 1:
if use a symbol as a key (obj[symbol]) on object,
since no one else can generate the same symbol
we can have "hidden" private properties (cf Van Roy)
o[s] = "pseudo private value"
	s won't show up in
		for loop
		Object.keys()
	but will show up in the String(o)
not quite true in reality, can get the "private" symbols used as keys of an obj:
	Object.getOwnPropertySymbols(o) returns the symbols of an object
	Reflect.ownKeys(o); returns all the keys (including symbols) of an object

Object.assign WILL copy the symbolic properties

String(Symbol("x"))
Symbol("x").toString()
	convert to string 'Symbol("id")' manually

Symbol("desc").description == "desc"
	gets the (string) description

Symbol.for('x')
	global registry of symbol
	Symbols in the registry are called global symbols
	create new or return existing symbol
	Symbol.for("x") == Symbol.for("x")
	Symbol("x") != Symbol.for("x")
	similar to smalltalk's #symbol

Symbol.keyFor(some_symbol)
	returns the description of a global symbol
	pointless : can use some_symbol.description
	can be used to determine if a symbol is global or not

Usage 2:
There are "system symbols" used by javascript implementation, defined in the js specs and used by some algorithms of the language:
Symbol.hasInstance, Symbol.iterator, Symbol.toPrimitive,...
Can alter the built-in behaviour:
- make an object iterable (we choose the returned elements)
- ...



var x = 0;
var x = 0, y = 1;
	set variable
	function (or global) scope (visible in the rest of the function)
var x;
	var has the value undefined
	different from x not being defined

x = 0;
	global var
	error in strict mode

let a = 12;
	block scope
	if executed in global scope, does NOT set a property on global object (window)

let a = 12;
let a = 11;
	error, can't declare a variable twice

const a = 12;
a = 11; // error
	block scope
	cannot reassign
	must assign a value;

variable name
	first character:  letter, $, _
	other characters: number, letter, $, _
	case sensitive
	there are reserved names (strict mode)
	camel case
	uppercase + _ for constant


,
	lower precedence than =
	evaluate expr to the left of , 
	evaluate expr to the right of , 
	return result of right/last one
	commonly used when assigning value (variables creation, for loop)



-- Array ---
['hi', 1, true]
new Array('hi', 1, true);
	rarely used (more verbose than array literal)
	if single argument of type number : create an array of that size!
array is an object with extra stuff (length, managing the ordered collection)
can be sparse
	a = [];
	a[10] = null;
	a.length === 11
== on two arrays is always false unless it is the same array (like all objects)
delete array[i]
	sets element to undefined
Array.isArray
	typeof [] is 'object'
	this allows to tell if something is an array
push(elem);
push(elem, elem2);
	add to the right
unshift(first)
unshift(first, second)
	add to the left
pop()
	remove last
shift()
	remove first
.length
	last index + 1
	writable!
[1, "hi"].join(", ");
	"1, hi"
	see also str.split
slice(from_i, [to_i])
	returns new subarray with elements
	does not modify the array
splice(start, deleteCount, item1, item2, itemN)
	-remove items
	-remove and add items
	-add items (deleteCount = 0)
	in place
	returns removed elements
arr.concat(arg1, arg2)
	does not change arr
	returns new array with arr concatenated to arg1, arg2,..
	args can be array or single elements
	if arg is an object with a [Symbol.isConcatSpreadable] property then all the property values of that object will be added to the result (instead of the object itself)
indexOf(item, from)
lastIndexOf(item, from)
includes(item, from)
	search for element. Uses ===
some
every
flat
flatMap
find(fn)
	returns undefined or the first match
	fn = function(item, index, array){}
findIndex(fn)
	like find but returns the index
filter(fn)
	returns array of all matching
map(fn)

reduce(fnWithAcc, optionalInitialValue)
sort(compareFn)
	sorts in place
	!! if no compareFn => sorted as string
		[1, 2, 15].sort() => [1, 15, 2]!
	compareFn(a, b) returns positive/zero/negative number
reverse()
	in place
a_function(...array)
	= a_function(array[0], array[1], array[2]);

for(let value of array){}
	iterate
forEach(function(item, index, array){})

Math.max(...array)
	largest value in an array
	string converted to number
	other value : returns NaN



{key:0, "k":0}
	create an object
	key : string or identifier
	looks like a dictionary but isn't : 
		is an object
		default keys
		keys are string only
		no size attribute
	use new Map() for a real dictionary type
a.key
a["key"]
	get value of key


m = new Map();
m.set("x");


a = [0, 1];
a = new Array();



if(x){
    console.log("yup");
}else if(true) {
    console.log("nope");
}else{
    console.log("nope")
}

if("hi") true
	converts content of () into a boolean value
	
true ? 1 : 2;
	ternary operator

v = 'a';
switch(v){
    case 'a':
        console.log("this is a");
        break;
    case 'A':
        console.log("this is A");
        break;
    default:
        console.log("other");
        break;
}


while(x > 0) {...}
do { ... } while(x > 0)

outer: for(let i = 0; i < 10; i++) {
    for(let j = 0; j < 3 ; j++) {
        console.log(i, j);
        break outer;
    }
}
	can break of outer loop by giving a label

for(let x = 0; x < 2; x++){};
for(let x in obj){};
	enumerable property names of objects
	included enumerable inherited properties
	order of iteration
		if key is string : order of property creation
		if key is string representing non negative integers:
			sorted integers first
			then other strings
			0, 1, 2, ... => integer properties
			-1, +2, ...  => NOT integer properties (sorted as string)
		(I imagine it is useful if iterate over an array, obsolete : nowadays would use for...of)
	iterate on
		object	(x are the Enumerable keys)
		array	(prefer the use of for..of)
		Map		(prefer the use of for..of)
		NOT string (works but keys: 0, 1, 2,... prefer the use of for..of)
	it's a weird choice to enumerator object (outside debugging?)
	hasOwnProperty()
		exclude properties of prototypes
		builtin properties (of Object) already ignored
for(let x of iterable){};
	iterate on iterable objects
	iterable[Symbol.iterator] magic behind the scene
	iterate on
		array
		string
		Map
		Set
		NodeList (document.querySelectorAll)
		Object.entries/keys/values(an_object) to iterate over objects
forEach
a.forEach(elem => console.log(elem));
a.forEach((elem, index) => console.log(elem, index));
a.forEach((elem, index, array) => console.log(elem, index, array));
	for arrays




function

a function with no return value or no return
	returns undefined

(function() {
    //...
})();
	IIFE
	Immediately Invoked Function Expression


Arrow function
() => { return 2 }
() => 2
x => { return x; }
x => x
(x,y) => { return x+y; }
(x,y) => x+y
	lambda

arrow function don't have their own this
this comes from the context!
Useful and intuitive when create an arrow function within a function


a();
function a() {console.log("a");}
	function declaration
	call before definition ok (hoisting)

b();
b = function() {console.log("b");};
	function expression
	ko : b doesn't exist at the moment of the call

c();
c = () => console.log("c!");
c = one_param => console.log("c!");	// no ()
c = (p1, p2) => console.log("c!");
c = (p1, p2) => {console.log("c!"); ... };
	ko : c doesn't exist at the moment of the call


default parameter
function foo(param=[]){
    param.push("hi");
    console.log(param);
}
foo(); // no arg
foo(undefined); 
	default parameter used if no arg passed OR undefined passed!
	(but default NOT used if null)
	default parameter evaluated each call
		opposite of python where it is evaluated once
		risk of modifying a default arg and affecting subsequent calls does not exist



--- OO ---

{}
	object initializer
	aka object literal
	keys converted to string

{
  [a_var]:1; //any expression really
}
	computed property
	Take the value, use its string representation as the key

name = "John";
{
  name // equivalent to name: name
}
	property value shorthand
	result : Object { name: "John" }

obj = {
  shorthandMethod(){ // equivalent to shorthandMethod: function() {
    ...
  }
}
	method definition shorthand
	! contrary to the long form cannot be used as a constructor ??? why
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#method_definitions


obj.key = x;
obj["key"] = x;

"property_name" in obj
	test if the property exists
	almost like obj.property_name !== undefined but returns true if we stored undefined in property_name

delete object.property
delete object["property"]
	removes key from object

object converted to boolean : always true



the way the function is called determines if it is:
	- a function (this not attached to object but global/undefined)
	- a method (this = object)
	(except if used bind)
this is the opposite of python and many languages where this in a method is always bound to an object
a = {
    attr: 0,
    func: function() {
        return this;
    }
}
a.func(); // this = a
f = a.func
b = f() // this = global object

Can take any function and attach it as an attribute to the object : 'this' will be the object if called through the object (exception bind)
a.fn = some_random_function

a_function.call(this_object, 0, 1);
	calls the function with a certain this object and arguments
a_function.apply(this_object, [0, 1]);
	same but args is an array
	can be used to splat an array:
	a = [0, 1, 2]
	Math.min.apply(Math, a); // array converted to individual arguments

bound_function = a_function.bind(this_object, 0, 1);
	return a new function whose this is permanently attached to this_object
	and the first arguments always are the ones specified (0, 1)
	bound_function() ~= a_function.call(this_object, 0, 1);
	stronger than call, apply, an_obj.bound_function()!

if call a function without an object, this:
	- non strict: 	global object
	- strict: 		undefined

Constructor
new aFunction()
	aFunction is (used as) a Constructor
	creates a new object, within the function 'this' is that object
	that object is returned
	BUT if return a object (type object only, no primitive) : will be the object returned
	aFunction() {...; return {};}
		{} will be the object created
	aFunction() {...; return "4";}
		not a valid object, the created "this object" will be returned
	if no argument, can omit the () : new aFunction <=> new aFunction()

var Constructor = function() {
    this.x = "x";	//within it, this is the new object which will be returned
};
o = new Constructor(); // new object
o.x === "x"

immediately called constructor
let user = new function(){
	this.x = ...
	...
};
	immediately called constructor function
	wrap object creation related code in a single place

new.target
	within the function
	if not called with new :	undefined
	if called with new :		= the function


Prototype
object have prototype
prototype can itself have a prototype
attribute access looks up the prototype chain

myobj = Object.create(a_prototype);
	associate a new object with a prototype
	??? has a second argument propertiesObject (to define properties?)
or
function Constructor() {}
Constructor.prototype = {
    number: 5,
    getNumber: function() {
        return this.number;
    }
}

12 !== new Number(12)
typeof 12 => number
typeof new Number(12) => object

Number.prototype.decuple = function() {
    return this*10;
}
	can change prototype of builtins
	sometimes used for polyfilling

Object.assign(target, ...sources)
	take all the enumerable own properties of the source objects and put it into target
	returns target
	shallow clone (property values of source are copied by value)
	order important (later overwrite earlier)
	??? how are properties handled? https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#description



Primitive conversion
no operator overloading (redefine '+' operator in obj1 + obj2)
but can control (some) conversions of obj (to string/number/default)
obj->boolean : always true, NO control
	eg !obj, obj === true (but NOT obj == true which uses default), Boolean(obj)
obj->string : can control
	"string" hint
	eg alert(obj), anotherObj[obj], String(o)
	! NOT "a string" + obj
obj->number : can control
	"number" hint
	eg obj1 - obj2, Number(obj), obj1 > obj2, 0 > obj, "str" > obj
default conversion
	"default" hint
	eg obj1 + obj2, "str" + obj, if (obj == 1)
	used when not sure if number or string should be used
	in practice : all built-ins object convert to number (except date), we should do the same => treat number and default hints the same

Two ways
1. Modern
o = {
    [Symbol.toPrimitive](hint) {
        if(hint == 'string'){
            return "I am o!"
        }else{ // 'number' or 'default'
            return 0;
        }
    }
}
	Checked to see if exist first, used if exists
	must return a primitive type, error if return object

2. older
o = {
    toString(){
        return "I am o"
    },
    valueOf(){
        return 99;
    }
}
	checked if no Symbol.toPrimitive
	"string" hint : check toString then valueOf
	"number" "default" hints : check valueOf then toString
	can implement only one : eg toString
	must return primitive, result ignored if not a primitive (as if method didn't exist)

Since we can't return objects nor know which exact operation the conversion is for, the conversion system is of limited use (especially default/number).	
If want to keep things simple : 
-can implement only toString, will always be called (except boolean conversion). Good for debugging.
-States that objects not designed to perform operations on it.




alert("msg")

prompt("msg", displayed_default)
	return null if cancel

confirm("msg")
	return true or false


