???
Symbol "The symbol type is used to create unique identifiers for objects" https://javascript.info/types
weird comparison rules https://javascript.info/comparison

standard
last published:
https://www.ecma-international.org/publications/standards/Ecma-262.htm
includes proposals:
https://tc39.es/ecma262/
https://github.com/tc39/proposals

courses:
https://javascript.info/
https://developer.mozilla.org/en-US/docs/Web/JavaScript
https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/#basic-javascript
codeacademy
https://www.theodinproject.com/paths/foundations/courses/foundations
udemy
	ES2015	https://www.udemy.com/course/the-advanced-web-developer-bootcamp/
	ES6		https://www.udemy.com/course/modern-javascript-es6-for-react-js/
nodeschool

todo
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode


npm
npm install
-g
	install globally
-D
	devDependency (develop/stest)

npm init
	create project
-y --yes
	defaults, do not prompt questions


"use strict";
Introduced in EC5 (2009), backward incompatible changes
at beginning of script
at beginning of function
??? automatically enabled by modules and classes?

;
always ; recommended


==
	does type conversion
	if number + a string/boolean => the string/boolean converted to number
===
	no type conversion
	different type => different

typeof
	return string of the type

true/false	'boolean'
null		'object'	!
[]			'object'	!
{}			'object'
function() {}	'function'
() => none	'function'
class Foo{}	'function'
1			'number'
1n			'bigint'
Symbol("a")	'symbol


null
	no value, unknown, empty
	x = null; makes sense
	Number(null) === 0

undefined
	value not assigned
	x = undefined; to avoid
	Number(undefined) === NaN

null == undefined
	this is a special rule
	(eg. [] != {})

Number
numbers are double
0.1 + 0.2 == 0.30000000000000004
Number.MIN_SAFE_INTEGER
Number.MAX_SAFE_INTEGER
	around 10**15, 2^53-1
	Number.MAX_SAFE_INTEGER +1 === Number.MAX_SAFE_INTEGER + 2

Number(<something>)
+a_string
	convert to number (eg. a string)

Infinity
	obtained with the keyword or dividing by zero (except 0/0, Infinity/Infinity,..)
	
Nan
	cannot parse a number ParseInt(), Number()
	string + operation "foo" / 2



BigInt
	represents integer of any size
	! fairly recent (Safari 2020)
	BigInt(1)
	BigInt("1")
	1n 				// BigInt literal
	BigInt(1) + 1	// NO
	BigInt(1) == 1	// yes (also <, <=,...)
	BigInt(1) === 1 // false
	
	can use * + / ...
	/ rounds toward zero
	cannot use with Math.xxx



bitwise operators
AND ( & )
OR ( | )
XOR ( ^ )
NOT ( ~ )
LEFT SHIFT ( << )
RIGHT SHIFT ( >> )
ZERO-FILL RIGHT SHIFT ( >>> )
numbers are converted to signed 32 bits integers. Truncated if needed


logical operators
|| && ! ??
	if operand is not a boolean
		convert to boolean to evaluate if true/false
		if operand is returned (see below): returns the original value (not converted)
|| || || ...
	return first true value
	or last value
&& && && ...
	return first false value
	or first value

a ?? b
	nullish coalescing operator
	if a not null or undefined: returns a
	if a null or undefined: 	returns b
	fairly new (2020)
	useful to give a default value if something may not be defined
		alert(user ?? "Anonymous");

"13"[0] === "1"
"13".charAt(0) === "1"
"oh hello".substr(3, 4)		// from, length
"oh hello".substring(3, 7)  // from, to (excluded)
"hell".length === 4

"ba" < "bar"
	lexicographical order

`template literal ${expression}`
	${} = literal
`multi
	line`
	multiline (return and newline part of the string)

a_function`tagged template literal`
	call a_function passing the strings and ${} to it
foo`tagged ${"hi"}template literal ${1+1} hi`
same as : foo([ 'tagged ', 'template literal ', ' hi' ], 'hi', 2)

String(something)
	convert to string


var x = 0;
var x = 0, y = 1;
	set variable
	function (or global) scope (visible in the rest of the function)
var x;
	var has the value undefined
	different from x not being defined

x = 0;
	global var
	error in strict mode

let a = 12;
	block scope
	if executed in global scope, does NOT set a property on global object (window)

let a = 12;
let a = 11;
	error, can't declare a variable twice

const a = 12;
a = 11; // error
	block scope
	cannot reassign
	must assign a value;

variable name
	first character:  letter, $, _
	other characters: number, letter, $, _
	case sensitive
	there are reserved names (strict mode)
	camel case
	uppercase + _ for constant


,
	lower precedence than =
	evaluate expr to the left of , 
	evaluate expr to the right of , 
	return result of right/last one
	commonly used when assigning value (variables creation, for loop)

['hi', 1, true]
push(elem);
	add to the right
unshift(first)
	add to the left
pop()
	remove last
shift()
	remove first
.length
[1, "hi"].join(", ");
	"1, hi"
slice(from_i, [to_i])
	returns new subarray with elements
	does not modify the array
splice(start, deleteCount, item1, item2, itemN)
	-remove items
	-remove and add items
	-add items (deleteCount = 0)
	in place
	returns removed elements
a_function(...array)
	= a_function(array[0], array[1], array[2]);


{key:0, "k":0}
	create an object
	key : string or identifier
	looks like a dictionary but isn't : 
		is an object
		default keys
		keys are string only
		no size attribute
	use new Map() for a real dictionary type
a.key
a["key"]
	get value of key


m = new Map();
m.set("x");


a = [0, 1];
a = new Array();



if(x){
    console.log("yup");
}else if(true) {
    console.log("nope");
}else{
    console.log("nope")
}

if("hi") true
	converts content of () into a boolean value
	
true ? 1 : 2;
	ternary operator

v = 'a';
switch(v){
    case 'a':
        console.log("this is a");
        break;
    case 'A':
        console.log("this is A");
        break;
    default:
        console.log("other");
        break;
}


while(x > 0) {...}
do { ... } while(x > 0)

outer: for(let i = 0; i < 10; i++) {
    for(let j = 0; j < 3 ; j++) {
        console.log(i, j);
        break outer;
    }
}
	can break of outer loop by giving a label

for(let x = 0; x < 2; x++){};
for(let x in obj){};
	enumerable property names of objects
	included enumerable inherited properties
	iterate on
		object	(x are the Enumerable keys)
		array	(prefer the use or..of)
		Map		(prefer the use of for..of)
		NOT string (works but keys: 0, 1, 2,... prefer the use of for..of)
	it's a weird choice to enumerator object (outside debugging?)
	often use for..of
	hasOwnProperty()
		exclude properties of prototypes
		builtin properties (of Object) already ignored
for(let x of iterable){};
	iterate on iterable objects
	iterable[Symbol.iterator] magic behind the scene
	iterate on
		array
		string
		Map
		Set
		NodeList (document.querySelectorAll)
		Object.entries/keys/values(an_object) to iterate over objects
forEach
a.forEach(elem => console.log(elem));
a.forEach((elem, index) => console.log(elem, index));
a.forEach((elem, index, array) => console.log(elem, index, array));
	for arrays




function

a function with no return value or no return
	returns undefined

(function() {
    //...
})();
	IIFE
	Immediately Invoked Function Expression

() => { return 2 }
() => 2
x => { return x; }
x => x
(x,y) => { return x+y; }
(x,y) => x+y
	lambda


a();
function a() {console.log("a");}
	function declaration
	call before definition ok (hoisting)

b();
b = function() {console.log("b");};
	function expression
	ko : b doesn't exist at the moment of the call

c();
c = () => console.log("c!");
c = one_param => console.log("c!");	// no ()
c = (p1, p2) => console.log("c!");
c = (p1, p2) => {console.log("c!"); ... };
	ko : c doesn't exist at the moment of the call


default parameter
function foo(param=[]){
    param.push("hi");
    console.log(param);
}
foo(); // no arg
foo(undefined); 
	default parameter used if no arg passed OR undefined passed!
	(but default NOT used if null)
	default parameter evaluated each call
		opposite of python where it is evaluated once
		risk of modifying a default arg and affecting subsequent calls does not exist



OO
the way the function is called determines if it is:
	- a function (this not attached to object but global)
	- a method (this = object)
this is the opposite of python (bound method stays attached)
a = {
    attr: 0,
    func: function() {
        return this;
    }
}
a.func(); // this = a
f = a.func
b = f() // this = global object

Can take any function and attach it as an attribute to the object : 'this' will be the object if called through the object
a.fn = some_random_function

a_function.call(this_object, 0, 1);
	calls the function with a certain this object and arguments
a_function.apply(this_object, [0, 1]);
	same but args is an array
	can be used to splat an array:
	a = [0, 1, 2]
	Math.min.apply(Math, a); // array converted to individual arguments

bound_function = a_function.bind(this_object, 0, 1);
	return a new function whose this is permanently attached to this_object
	and the first arguments always are the ones specified (0, 1)
	bound_function() ~= a_function.call(this_object, 0, 1);
	stronger than call, apply, an_obj.bound_function()!

new a_function()
	a_function is (used as) a Constructor
	creates a new object, within the function 'this' is that object
	that object is returned
	BUT if return a object (type object only) : will be the object returned
	a_function() {...; return {};}
		{} will be the object created
	a_function() {...; return "4";}
		not a valid object, the created "this object" will be returned

var Constructor = function() {
    this.x = "x";	//within it, this is the new object which will be returned
};
o = new Constructor(); // new object
o.x === "x"

Prototype
object have prototype
prototype can itself have a prototype
attribute access looks up the prototype chain

myobj = Object.create(a_prototype);
	associate a new object with a prototype

or
function Constructor() {}
Constructor.prototype = {
    number: 5,
    getNumber: function() {
        return this.number;
    }
}

12 !== new Number(12)
typeof 12 => number
typeof new Number(12) => object

Number.prototype.decuple = function() {
    return this*10;
}
	can change prototype of builtins
	sometimes used for polyfilling



alert("msg")

prompt("msg", displayed_default)
	return null if cancel

confirm("msg")
	return true or false


