js warts
negative index : like 0 or count from the end of the array/string?
	inconsistant (indexOf and substring vs slice and substr)

objects used as dictionary (no length, perfs, limited keys)

???
Symbol "The symbol type is used to create unique identifiers for objects"
	https://javascript.info/types
Symbol as key
	"Bear in mind that enumerable properties are looped over by for...in loops, with the exception of Symbols. " https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable
enumerable (and own) object
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable
get/set
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set
	(+ impact on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign : "Therefore it assigns properties, versus copying or defining new properties. This may make it unsuitable for merging new properties into a prototype if the merge sources contain getters. ")
weird comparison rules
	https://javascript.info/comparison
generator
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*


standard
last published:
https://www.ecma-international.org/publications/standards/Ecma-262.htm
includes proposals:
https://tc39.es/ecma262/
https://github.com/tc39/proposals
unit test: mocha, jest

courses:
https://javascript.info/
https://developer.mozilla.org/en-US/docs/Web/JavaScript
https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/#basic-javascript
codeacademy
https://www.theodinproject.com/paths/foundations/courses/foundations
udemy
	ES2015	https://www.udemy.com/course/the-advanced-web-developer-bootcamp/
	ES6		https://www.udemy.com/course/modern-javascript-es6-for-react-js/
nodeschool

todo
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode


npm
npm install
-g
	install globally
-D
	devDependency (develop/stest)

npm init
	create project
-y --yes
	defaults, do not prompt questions

babel
	transpiler : convert modern js into js that can be run on older js engines
	to be combined with a polyfill

"use strict";
Introduced in EC5 (2009), backward incompatible changes
at beginning of script
at beginning of function
??? automatically enabled by modules and classes?

;
always ; recommended


==
	does type conversion
	if number + a string/boolean => the string/boolean converted to number
===
	no type conversion
	different type => different

Object.is(a, b)
	like === but
	NaN is NaN
	+0 is not -0
	

primitive types (singlue value, stored as value in variables)
string
number
bigint
boolean
symbol
null
undefined

Object type
	{}
	function
	array
	Map
	...

String, Number, Boolean, Symbol
	allow calling methods on primitive types
	eg aString.toUpperCase(), aNumber.toFixed(2)
	as if the js Engine created a temporary object wrapper around the primitive to allow an operation to carry out.

new Number(0)
new Boolean(false)
	create a wrapper object
	NEVER USE !!!
	awful:
		typeof is object
		considered truthy (like all objects)!!
			if(new Boolean(false)) console.log("this will print!")
			if(new Number(0)) console.log("this will print!")
	Number("123") ok : returns primitive

typeof
	return string of the type

true/false	'boolean'
null		'object'	!
[]			'object'	!
{}			'object'
function() {}	'function'
() => none	'function'
class Foo{}	'function'
1			'number'
1n			'bigint'
Symbol("a")	'symbol


null
	no value, unknown, empty
	x = null; makes sense
	Number(null) === 0

undefined
	value not assigned
	x = undefined; to avoid
	Number(undefined) === NaN

null == undefined
	this is a special rule
	(eg. [] != {})



--- Number ---
numbers are double
0.1 + 0.2 == 0.30000000000000004
Number.MIN_SAFE_INTEGER
Number.MAX_SAFE_INTEGER
	around 10**15, 2^53-1
	Number.MAX_SAFE_INTEGER +1 === Number.MAX_SAFE_INTEGER + 2

1_000_000_000
1e3 === 1000
1e2 === 100
1e1 === 10
1e0 === 1
1e-1=== 0.1

0xff
	hexa

0b01111111
	binary


0o10
	octal

010	
use strict : 	 error
non use strict : === 8, but Number("010") === 10

Number(<something>)
+a_string
	convert to number (eg. a string)

parseInt(str)
parseInt(str, radix) // default 10
parseFloat(str)
	convert to number
	ignore non-number text at the end of the string
	Number("123x") === NaN
	parseInt("123x") === 123

Infinity
	obtained with the keyword or dividing by zero (except 0/0, Infinity/Infinity,..)
	
Nan
	cannot parse a number ParseInt(), Number()
	string + operation "foo" / 2


aNumber.toString()
aNumber.toString(2) // base

2.toString() // error
(2).toString() 2..toString() // ok


BigInt
	represents integer of any size
	! fairly recent (Safari 2020)
	BigInt(1)
	BigInt("1")
	1n 				// BigInt literal
	BigInt(1) + 1	// NO
	BigInt(1) == 1	// yes (also <, <=,...)
	BigInt(1) === 1 // false
	
	can use * + / ...
	/ rounds toward zero
	cannot use with Math.xxx



bitwise operators
AND ( & )
OR ( | )
XOR ( ^ )
NOT ( ~ )
LEFT SHIFT ( << )
RIGHT SHIFT ( >> )
ZERO-FILL RIGHT SHIFT ( >>> )
numbers are converted to signed 32 bits integers. Truncated if needed


logical operators
|| && ! ??
	if operand is not a boolean
		convert to boolean to evaluate if true/false
		if operand is returned (see below): returns the original value (not converted)
|| || || ...
	return first true value
	or last value
&& && && ...
	return first false value
	or first value

a ?? b
	nullish coalescing operator
	nullish = null or undefined ( https://developer.mozilla.org/en-US/docs/Glossary/Nullish )
	if a not null or undefined: returns a
	if a null or undefined: 	returns b
	fairly new (2020)
	useful to give a default value if something may not be defined
		alert(user ?? "Anonymous");

a?.b
	optional chaining
	the object on the left may not exist
	if a is nullish (null/undefined) return undefined
	if a exists returns value of b (which can be undefined)
	permits: a?.b?.c
	a && a.b && a.b.c is similar but
		more verbose
		if falsish value : return falsish value instead of undefined
	the variable a must exist (but may be null/undefined) otherwhise exception
object.function?.()
	calls the function if it exists
	returns undefined if it does not exist
object?.[key]
array?.[i]
	read if object/array exists, otherwise returns undefined
delete obj?.value
	delete obj.value if obj exists
a_null_variable?.name = "John";
	SyntaxError (cannot do what amounts to undefined = "x");



--- String ---

"13"[0] === "1"
"13".charAt(0) === "1"		// was the only way originally
"hell".length === 4

"ba" < "bar"
	lexicographical order
	uppercase before lowercase  (cf ASCII table)
	diacritical marks after non diacritical marks (z < รถ) (cf unicode)
	str.localeCompare to be language aware

`template literal ${expression}`
	${} = literal
`multi
	line`
	multiline (return and newline part of the string)

a_function`tagged template literal`
	call a_function passing the strings and ${} to it
foo`tagged ${"hi"}template literal ${1+1} hi`
same as : foo([ 'tagged ', 'template literal ', ' hi' ], 'hi', 2)

String(something)
	convert to string

str.localeCompare(otherString)
	compare with locale awareness. Eg. ร < P

str.toUpperCase()

str.indexOf(searchedString, fromIndex)
	returns index
	-1 if not found
	! careful:  if(str.indexOf(...)) <== wrong (fails on -1, 0) use includes instead
	negative index like 0

str.includes(searchedString, fromIndex)
	returns true/false


"oh hello".substring(3, 7)
	returns substring
	from, to (excluded)
	can ommit to
	negative index like 0
	if from > to => swaps index

str.slice(startI, endI)
	modern version of substring.
	similar:
	returns substring
	endI excluded
	can ommit endI
	different:
	negative index counts from end of string (-1 = last index)
	if start > end => empty

str.substr(startI, length)
	negative index counts from end of string (-1 = last index)

str.split(', ')
	turn string into array based on the delimiter



--- Symbol ---
Unique identifier
NOT like string
NOT like smalltalk's #symbol


Symbol("a") != Symbol("a")
	each symbol is unique
	even if same description
	(exception see global registry Symbol.for)

alert(Symbol("hi"))
"My symbol is " + Symbol("hi")
	TypeError, symbols do not auto convert to string

Usage 1:
if use a symbol as a key (obj[symbol]) on object,
since no one else can generate the same symbol
we can have "hidden" private properties (cf Van Roy)
o[s] = "pseudo private value"
	s won't show up in
		for loop
		Object.keys()
	but will show up in the String(o)
not quite true in reality, can get the "private" symbols used as keys of an obj:
	Object.getOwnPropertySymbols(o) returns the symbols of an object
	Reflect.ownKeys(o); returns all the keys (including symbols) of an object

Object.assign WILL copy the symbolic properties

String(Symbol("x"))
Symbol("x").toString()
	convert to string 'Symbol("id")' manually

Symbol("desc").description == "desc"
	gets the (string) description

Symbol.for('x')
	global registry of symbol
	Symbols in the registry are called global symbols
	create new or return existing symbol
	Symbol.for("x") == Symbol.for("x")
	Symbol("x") != Symbol.for("x")
	similar to smalltalk's #symbol

Symbol.keyFor(some_symbol)
	returns the description of a global symbol
	pointless : can use some_symbol.description
	can be used to determine if a symbol is global or not

Usage 2:
There are "system symbols" used by javascript implementation, defined in the js specs and used by some algorithms of the language:
Symbol.hasInstance, Symbol.iterator, Symbol.toPrimitive,...
Can alter the built-in behaviour:
- make an object iterable (we choose the returned elements)
- ...



--- variables ---


var x = 0;
var x = 0, y = 1;
	set variable
	function (or global) scope (visible in the rest of the function)
var x;
	var has the value undefined
	different from x not being defined

function foo(){
    x = 1 //local, despite the later var x 
    var x;// same with if(false){var x;}
}
foo();
console.log(x) // x is not defined
	a declaration of a variable _anywhere_ with var is enough to make it  a local/function scoped variable

x = 0;
	global var
	error in strict mode

let a = 12;
	block scope
	if executed in global scope, does NOT set a property on global object (window)

let a = 12;
let a = 11;
	error, can't declare a variable twice

for(let i = 0; i < 3 ; i++) {
    arr.push(function foo(){
        console.log(i); //i different with let. Would be the same xith var
    });
}

const a = 12;
a = 11; // error
	block scope
	cannot reassign
	must assign a value;

function foo(){}
	hoisted
	in strict mode : function definition is block scoped : exists only within the block

variable name
	first character:  letter, $, _
	other characters: number, letter, $, _
	case sensitive
	there are reserved names (strict mode)
	camel case
	uppercase + _ for constant


,
	lower precedence than =
	evaluate expr to the left of , 
	evaluate expr to the right of , 
	return result of right/last one
	commonly used when assigning value (variables creation, for loop)



-- Array ---
['hi', 1, true]
new Array('hi', 1, true);
	rarely used (more verbose than array literal)
	if single argument of type number : create an array of that size!
array is an object with extra stuff (length, managing the ordered collection)
can be sparse
	a = [];
	a[10] = null;
	a.length === 11
== on two arrays is always false unless it is the same array (like all objects)
delete array[i]
	sets element to undefined
Array.isArray
	typeof [] is 'object'
	this allows to tell if something is an array
push(elem);
push(elem, elem2);
	add to the right
unshift(first)
unshift(first, second)
	add to the left
pop()
	remove last
shift()
	remove first
.length
	last index + 1
	writable!
[1, "hi"].join(", ");
	"1, hi"
	see also str.split
slice(from_i, [to_i])
	returns new subarray with elements
	does not modify the array
splice(start, deleteCount, item1, item2, itemN)
	-remove items
	-remove and add items
	-add items (deleteCount = 0)
	in place
	returns removed elements
arr.concat(arg1, arg2)
	does not change arr
	returns new array with arr concatenated to arg1, arg2,..
	args can be array or single elements
	if arg is an object with a [Symbol.isConcatSpreadable] property then all the property values of that object will be added to the result (instead of the object itself)
indexOf(item, from)
lastIndexOf(item, from)
includes(item, from)
	search for element. Uses ===
some
every
flat
flatMap
find(fn)
	returns undefined or the first match
	fn = function(item, index, array){}
findIndex(fn)
	like find but returns the index
filter(fn)
	returns array of all matching
map(fn)

reduce(fnWithAcc, optionalInitialValue)
sort(compareFn)
	sorts in place
	!! if no compareFn => sorted as string
		[1, 2, 15].sort() => [1, 15, 2]!
	compareFn(a, b) returns positive/zero/negative number
reverse()
	in place
	
a_function(...array)
	= a_function(array[0], array[1], array[2]);
	spread operator

for(let value of array){}
	iterate
forEach(function(item, index, array){})

let arr = 'hello over there'.split(' ')
let  [a, , b] = arr
	array destructuring
	any iterable on the right side

-- Iterable ---
objectThatMustBeIterable[Symbol.iterator] = function() {
    return {
        next() {
            return {done: false, value: this.current++};
            return {done: true};
        }
    };
};

Can make a self-iterable
range[Symbol.iterator] = function() {
    return this;
}
range.next = function() {
    return {done: false, value: xxx};
    return {done: true};
};
	downside : only one iteration possible

Manually interating :
    iterator = iterable[Symbol.iterator]();
    while(true){
        let result = iterator.next();
        if(result.done) break;
        console.log(result.value)
    }


Array like object
	an object with keys: 0, 1, 2,... and length

Array.from(arrayLike)
Array.from(iterable)
	returns an object which behaves like an array:
		all the methods (push,...)
		for..of
		indexed access
	works on non array-like/iterable : as if the object was an empty array
[...anIterable]
	creates array from iterable

[a, b, ...rest] = anIterable
	destructuring
[a="default", b="default", ...rest] = anIterable
	can provide default value

similar exists for objects : {...obj}


--- Map ---
{key:0, "k":0}
	creates an object
	looks like a dictionary but isn't : 
		is an object
		default keys
		keys are string (or symbol) only
		no size attribute
use new Map() for a real dictionary type
	allows keys of any type

can have object as key

key does not have to be readonly
no equality/hash operator overloading
comparisoin based on identity

m = new Map();
m = new Map([ ['k', 'v'], ['k2', 'v2']])
m = new Map(Object.entries(obj))
set(key, value)
	can chain
get(key)
has(key)
delete(key)
clear()
size

Object.fromEntries(map)
	makes a plain object from a map object
	map = iterable/array like
	can use Object.entries(o) as source

for(let v of m)
	iterate on entries [key, value]
for(let v of m.keys())
for(let v of m.values())
forEach( (value, key, map) => ...)

WeakMap
	like map but
		key must be an object
		removed automatically if object has no other reference
		typical use : 
		-add info to an object belonging to other code. Do not want to modify the object itself but still want associated data
		- cache the result of a computation (for a given object)
	no size
	no iteration

-- set --
new Set()
new Set(iterable)
add(value)
delete(value)
has(value)
clear()
size

for(let v of m)
for(let v of m.keys()) //useless
for(let v of m.values()) // for compat with map, same as keys
for(let v of m.entries()) // for compat with map : [value, value]
forEach((value, valueAgain, set) => ...)
	works on Map, Set, Array
	note : also exists Object.keys, Object.values, Object.entries for objects (different from functions here)

WeakSet
	only contains objects
	no size
	no iteration
	does contain has, delete
	can determine if an element is or is not in the set
	eg.: message has been read if is in the set.



if(x){
    console.log("yup");
}else if(true) {
    console.log("nope");
}else{
    console.log("nope")
}

if(variable = xxx) yyy;
	assign xxx to variable

if("hi") true
	converts content of () into a boolean value
	
true ? 1 : 2;
	ternary operator

v = 'a';
switch(v){
    case 'a':
        console.log("this is a");
        break;
    case 'A':
        console.log("this is A");
        break;
    default:
        console.log("other");
        break;
}


while(x > 0) {...}
do { ... } while(x > 0)

outer: for(let i = 0; i < 10; i++) {
    for(let j = 0; j < 3 ; j++) {
        console.log(i, j);
        break outer;
    }
}
	can break of outer loop by giving a label

for(let x = 0; x < 2; x++){};
for(let x in obj){};
	enumerable property names of objects
	included enumerable inherited properties
	order of iteration
		if key is string : order of property creation
		if key is string representing non negative integers:
			sorted integers first
			then other strings
			0, 1, 2, ... => integer properties
			-1, +2, ...  => NOT integer properties (sorted as string)
		(I imagine it is useful if iterate over an array, obsolete : nowadays would use for...of)
	iterate on
		object	(x are the Enumerable keys)
		array	(prefer the use of for..of)
		Map		(prefer the use of for..of)
		NOT string (works but keys: 0, 1, 2,... prefer the use of for..of)
	it's a weird choice to enumerator object (outside debugging?)
	hasOwnProperty()
		exclude properties of prototypes
		builtin properties (of Object) already ignored
for(let x of iterable){};
	iterate on iterable objects
	iterable[Symbol.iterator] magic behind the scene
	iterate on
		array
		string
		Map
		Set
		NodeList (document.querySelectorAll)
		Object.entries/keys/values(an_object) to iterate over objects
forEach
a.forEach(elem => console.log(elem));
a.forEach((elem, index) => console.log(elem, index));
a.forEach((elem, index, array) => console.log(elem, index, array));
	for arrays



-- Date --
Date and time
important:
	use FullYear NOT year
	month : 0-based (0 = january)
	day: use getDate NOT getDay
	getDay : day in the week, 0-based (0=sunday)
	timestamp are in ms, not s as is more common
	autocorrection when date is out of range
	by default values are set/returned relative to current timestamp
	can set/get values relative to utc with UTC variant of methods

new Date()
	current date/time
Date()
	current date as a string!
new Date(existingDate)
new Date(ms_since_1_1_1970)
	date.getTime() to get the timestamp
	date can be before 1970 => negative timestamp value
new Date("2017-01-26")
new Date("2017-01-26 01:02:59")
new Date("YYYY-MM-DDTHH:mm:ss.sssZ")
	or Date.parse(str)
	Z is the time zone
		Z = UTC+0
		+-hh:mm
		(time will be set relative to that timezone, the created date will be displayed relative to the local timezone)
new Date(year, month, date, hours, minutes, seconds, ms)
	month: 0 = jan
uses local time zone

getTime
	returns the timestamp
Date.now()
	returns current timestamp
	shortcut for new Date().getTime()

getFullYear
getMonth // 0-11, 0 = january !
getDate // day in the current month !
getHours getMinutes getSeconds getMilliseconds
getDay
	day of the week 0=sunday, 6=saturday
getYear
	do NOT use
	weird value

variations of above methods:
setxxx
	set the value
	Date objects are mutable
setUTCxxx
	sets the value relative to UTC. Date object remains in local time
	setUTCHour(22) and local timezone at T+1? => getHours() will be 23
getUTCxxx
	(add UTC)
	value relative to UTC instead of local time
getTimezoneOffset
	difference in minutes between local timezone (timezone used in the date object) and UTC

autocorrection
if create a date/set a value too big/too small
	will auto adjust
	new Date(2000, 0, 32) => date will be in february
useful :
	set the date to x seconds after the date : date.setSeconds(date.getSeconds()+x);
	set the date to the last day of the previous month : setDate(0)
double edged : can give wrong value and there won't be an error

conversion to primitive (number timestamp)
+aDate
	converts date to timestamp (see primitive conversion)
aDate - anotherDate
	difference in timestamp => difference in ms



--- function ---

a function with no return value or no return
	returns undefined

function foo(){}
	function declaration

const foo = function(){}
	function expression

const foo = function bar(){}
	named function expression

const func = new Function('arg1', 'return arg1 + 1;')
	new Function syntax to create a function from string
	not to be confused with object creation through constructor call
	no access to variables available in the environment where new Function is called

(function() {
    //...
})();
	IIFE
	Immediately Invoked Function Expression
	not too useful anymore can be replaced in most situation with a block {}
	case where still useful : 
	- want to assign the result of a calculation to a const
	  const foo = (function(){...return x;})();


Arrow function
() => { return 2 }
() => 2
x => { return x; }
x => x
(x,y) => { return x+y; }
(x,y) => x+y
	lambda

arrow function don't have their own this
this comes from the context!
Useful and intuitive when create an arrow function within a function



a();
function a() {console.log("a");}
	function declaration
	call before definition ok (hoisting)

b();
b = function() {console.log("b");};
	function expression
	ko : b doesn't exist at the moment of the call

c();
c = () => console.log("c!");
c = one_param => console.log("c!");	// no ()
c = (p1, p2) => console.log("c!");
c = (p1, p2) => {console.log("c!"); ... };
	ko : c doesn't exist at the moment of the call


default parameter
function foo(param=[]){
    param.push("hi");
    console.log(param);
}
foo(); // no arg
foo(undefined); 
	default parameter used if no arg passed OR undefined passed!
	(but default NOT used if null)
	default parameter evaluated each call
		opposite of python where it is evaluated once
		risk of modifying a default arg and affecting subsequent calls does not exist



a_function(...array)
	rest parameters
	= a_function(array[0], array[1], array[2]);
[1, 2, ...array]
	spread operator


function foo(...array)
	rest parameters
	array is a regular array

Math.max(...array)
	largest value in an array
	string converted to number
	other value : returns NaN

arguments
	within a function : the arguments passed
	arrow functions don't have their own arguments (it is the one of the parent function)
	array-like, iterable but does not an array : does not support array function
theFunction(...args){}
	alternative to arguments
	real array


a function is an object. It can have properties
name
	name of the object
foo = function(){] //foo.name === "foo"
obj.prop = function(){] //obj.prop.name === "prop"
	contextual name
	if no name : uses name of variable it is assigned to!
array.push(function(){}); //array.pop().name === "" got em!

length
	number of parameters



--- OO ---

{}
	object initializer
	aka object literal
	keys converted to string

a.key
a["key"]
	get value of key

{
  [a_var]:1; //any expression really
}
	computed property
	Take the value, use its string representation as the key

name = "John";
{
  name // equivalent to name: name
}
	property value shorthand
	result : Object { name: "John" }

obj = {
  shorthandMethod(){ // equivalent to shorthandMethod: function() {
    ...
  }
}
	method definition shorthand
	! contrary to the long form cannot be used as a constructor ??? why
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#method_definitions


obj.key = x;
obj["key"] = x;

"property_name" in obj
	test if the property exists
	almost like obj.property_name !== undefined but returns true if we stored undefined in property_name

delete object.property
delete object["property"]
	removes key from object

object converted to boolean : always true

Object.keys()
Object.values()
Object.entries()
	return arrays (contrary to map.xxx, set.xxx, Array.xxx which return an iterable)
	do not appear:
		symbols
		properties with flag writable: false
	(can get them with Reflect.ownKeys())

for(let [key, value] of Object.entries(obj)){}



-- Properties --
property attributes : value + flags
property flags:
writable		read-only or not?	
enumerable		appear in loops
configurable	can be deleted, flags can be changed
a normal property : 3 flags true

for a getter/setter property:
get
set
enumerable
configurable

writable: false
	write non strict : nothing happens
	write strict: error

configurable: false
	prevents property from being deleted
	cannot change flags/value (EXCEPTION : can set writable to false)
	often combined with writable false otherwise can set writable back to true with Object.defineProperty


Accessor descriptor : object describing a property (configurable, enumerable,...)

Object.getOwnPropertyDescriptor(obj, propertyName)
	returns a property descriptor : value + flags

Object.getOwnPropertyDescriptors(obj)
	get proprety descriptors for all properties
	returns an object: {propertyName: {propertyDescriptor}, ...}
		same object structure as in defineProperties

Object.defineProperty(obj, propertyName, descriptor)
	sets attribute
	eg. Object.defineProperty(o, "a", {value: "hello", enumerable:false})
	if creates a new property: missing flags are assumed false

Object.defineProperties(obj, {
	prop1: {...},
	prop2: {...},
})
	same object structure as in getOwnPropertyDescriptors

Object.getOwnPropertySymbols(o)
	get all Symbol properties
Reflect.ownKeys(o)
	all the keys (string and symbols)

Object.isExtensible(obj)
Object.preventExtensions(obj);
	cannot add new properties
	
Object.isSealed(obj)
Object.seal(obj);
	cannot add/remove properties.
	Sets configurable: false on all properties
	
Object.isFrozen(obj)
Object.freeze(obj)
	cannot add/remove/change any property.
	Sets configurable: false, writable: false on all properties


data property : usual property
accessor property : property with a getter/setter method behind it.

let obj = {
  get propName() {
    // getter, the code executed on getting obj.propName
  },

  set propName(value) {
    // setter, the code executed on setting obj.propName = value
  }
};

Create an accessor property with an accessor descriptor:
Object.defineProperty(object, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  },
  //enumerable, configureble..
});

to have a "private" backing field for a property:
_privateProperty



-- Object destructuring --
o = {
    a: "aa", 
    b: "bb",
    1: "one value",
}
let {a, b, 1: one} = o;
a === "aa"
b === "bb"
one === "one value" //variable name different from the key
	destructuring objects
	extract values of properties and put them in variables
let {width: w = 100, height: h = 200, title} = options;
	with default value

can have multiple levels
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};
// destructuring assignment split in multiple lines for clarity
let {
  size: { // put size here
    width,
    height
  },
  items: [item1, item2], // assign items here
  title = "Menu" // not present in the object (default value is used)
} = options;

let options = {
    title: "title", 
    items: [1]
}
function manyArgs({title = "default", items = [],...} = {}){}
manyArgs(options)
	can use on parameters


the way the function is called determines if it is:
	- a function (this not attached to object but global/undefined)
	- a method (this = object)
	(except if used bind)
this is the opposite of python and many languages where this in a method is always bound to an object
a = {
    attr: 0,
    func: function() {
        return this;
    }
}
a.func(); // this = a
f = a.func
b = f() // this = global object

Can take any function and attach it as an attribute to the object : 'this' will be the object if called through the object (exception bind)
a.fn = some_random_function

a_function.call(this_object, 0, 1);
	calls the function with a certain this object and arguments
a_function.apply(this_object, [0, 1]);
	same but args is an array
	can be used to splat an array:
	a = [0, 1, 2]
	Math.min.apply(Math, a); // array converted to individual arguments

bind(thisObject, arg1, arg2)
	return a new function whose this is _permanently_ attached to thisObject
	and the first arguments always are the ones specified (arg1, arg2)
	returnedFunction() ~= originalFunction.call(thisObject, 0, 1);
	call to bind does not affect the original function
	stronger than call, apply, an_obj.bound_function()! => this won't change
	cannot rebind
	useful for setTimeout(object.method) => can avoid losing object being this with bind
	the new function does NOT have the properties of the original

bind(null)
	bind to the global object

if call a function without an object, this:
	- non strict: 	global object
	- strict: 		undefined

Constructor
new aFunction()
	aFunction is (used as) a Constructor
	creates a new object, within the function 'this' is that object
	that object is returned
	BUT if return a object (type object only, no primitive) : will be the object returned
	aFunction() {...; return {};}
		{} will be the object created
	aFunction() {...; return "4";}
		not a valid object, the created "this object" will be returned
	if no argument, can omit the () : new aFunction <=> new aFunction()

var Constructor = function() {
    this.x = "x";	//within it, this is the new object which will be returned
};
o = new Constructor(); // new object
o.x === "x"

immediately called constructor
let user = new function(){
	this.x = ...
	...
};
	immediately called constructor function
	wrap object creation related code in a single place

new.target
	within the function
	if not called with new :	undefined
	if called with new :		= the function



Prototype
object have prototype
prototype can itself have a prototype
attribute access looks up the prototype chain

myobj = Object.create(a_prototype);
	associate a new object with a prototype
	??? has a second argument propertiesObject (to define properties?)
or
function Constructor() {}
Constructor.prototype = {
    number: 5,
    getNumber: function() {
        return this.number;
    }
}

12 !== new Number(12)
typeof 12 => number
typeof new Number(12) => object

Number.prototype.decuple = function() {
    return this*10;
}
	can change prototype of builtins
	sometimes used for polyfilling

Object.assign(target, ...sources)
	take all the enumerable own properties of the source objects and put it into target
	returns target
	shallow clone (property values of source are copied by value)
	order important (later overwrite earlier)
	??? how are properties handled? https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#description

Array.prototype.join.call(arguments)
	method borrowing



--- Primitive conversion ---
no operator overloading (redefine '+' operator in obj1 + obj2)
but can control (some) conversions of obj (to string/number/default)
obj->boolean : always true, NO control
	eg !obj, obj === true (but NOT obj == true which uses default), Boolean(obj)
obj->string : can control
	"string" hint
	eg alert(obj), anotherObj[obj], String(o)
	! NOT "a string" + obj
obj->number : can control
	"number" hint
	eg obj1 - obj2, Number(obj), obj1 > obj2, 0 > obj, "str" > obj
default conversion
	"default" hint
	eg obj1 + obj2, "str" + obj, if (obj == 1)
	used when not sure if number or string should be used
	in practice : all built-ins object convert to number (except date), we should do the same => treat number and default hints the same

Two ways
1. Modern
o = {
    [Symbol.toPrimitive](hint) {
        if(hint == 'string'){
            return "I am o!"
        }else{ // 'number' or 'default'
            return 0;
        }
    }
}
	Checked to see if exist first, used if exists
	must return a primitive type, error if return object

2. older
o = {
    toString(){
        return "I am o"
    },
    valueOf(){
        return 99;
    }
}
	checked if no Symbol.toPrimitive
	"string" hint : check toString then valueOf
	"number" "default" hints : check valueOf then toString
	can implement only one : eg toString
	must return primitive, result ignored if not a primitive (as if method didn't exist)

Since we can't return objects nor know which exact operation the conversion is for, the conversion system is of limited use (especially default/number).	
If want to keep things simple : 
-can implement only toString, will always be called (except boolean conversion). Good for debugging.
-States that objects not designed to perform operations on it.



alert("msg")

prompt("msg", displayed_default)
	return null if cancel

confirm("msg")
	return true or false



--- Global object ---
window in browser
global in node
globalThis in browser and node (since 2019)

var foo = x;
console.log(window.foo);

global.foo = 1
console.log(foo);
	bad to put variables in the global object
	useful for polyfill



--- JSON ---
RFC4627
a JSON string called : JSON-encoded, serialized, marshalled.
differences from object literals:
	strings are double quotes
	property keys are within quotes
	no properties with undefined value
	no function
	no Symbols
	no comments
	
JSON.stringify(value)
JSON.stringify(value, replacer)
	replacer : array of string or function
JSON.stringify(value, ["a", "b"])
	in objects only properties with these names will be encoded
JSON.stringify(value, function(key, value){})
	! first call to it will have empty key and the object passed to stringify as value
	this is the object which possess the property
	return undefined to skip property
	return a value : that value will be the one encoded
JSON.stringify(value, replacer, space)
	space
	0 = one-line compact
	1+ = on multiple lines + size of indentation

toJSON
	function attached to an object
	returns string representation
	used by stringify


JSON.parse(str)
JSON.parse(str, reviver)
	reviver is a function(key, value)
	convert the string value back into js representation
	returning undefined = do not deserialize that property
	eg: dates



--- timeout interval ---
timerId = setTimeout(func, delay, arg1, arg2,...)
timerId = setInterval(func, delay, arg1, arg2,...)
clearTimeout(timerId);

this is the window object (Timer object in node)

zero delay scheduling: delay == 0. wait for the current code to stop running before running it

careful: 
- memory leak : everything func refers to (variables outside the function) won't be GC'ed until clearTimeout has been called

- delay is NOT wait 'delay' amount of time after last execution before calling it again
	it is : call func every 'delay'
	problematic if the function is slow => short/no pause between calls
	can be fixed by  rescheduling the calls ourself with setTimeout

- can lose the this
	setTimeout(object.method, 1000)
	method will be called without the object. Wrong this.
	fix with bind



--- Regex ---
new RegExp("pattern", "flags");
/pattern/gmi

flags
i	case insensitive
g	global, all matches not just the first
m	multiline mode, ^ and $ match at beginning/end of line not just string

str.match(regexp)
	if g flag : array of matches (simple strings)
	if no g flag: array representing a match (details on the match)
		[0] = matched, [1] first group,..
		length	number of indexes (result+groups)
		index
		input
		groups ???
	if not match: null !!! (g or no g)

str.matchAll(regexp)
	regexp must have the g flag
	returns an iterable of objects representing a match
	returns empty array if no match

str.replace(regexp, replacement)
	if no g :	replace first
	if g: 		replace all
	replacement accepts special value which will be replaced by part of the match

aRegexp.test(string)
	is there a match

str.split(regexp)
	returns array

str.search(regexp)
	position of first match or -1

--- DOM ---
<div id="foo">hello</div>
<script>
    foo.textContent = "new content";
    window.foo.textContent = "new content";
</script>
    Named access on the Window object
    all nodes with id are added to the window object
    (and thus globally available)
	Crazy (bad) because
	- it can clash with window's default properties
		(window's built-in properties win in that case)
	- it can clash with global variables set in js
		(global var wins in that case)
    https://stackoverflow.com/questions/3434278/do-dom-tree-elements-with-ids-become-global-variables
    https://html.spec.whatwg.org/multipage/window-object.html#named-access-on-the-window-object


