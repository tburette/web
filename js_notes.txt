js warts
negative index : like 0 or count from the end of the array/string?
	inconsistant (indexOf and substring vs slice and substr)

objects used as dictionary (no length, perfs, limited keys)

o == 1 => not the number primitive conversion but the string one

let proto = {
    stomach: [],
    eat(food) {
      this.stomach.push(food); // changes proto.stomach)
      this.stomach = [food]; // set stomach on the instance object)
    },
}
instance = Object.create(proto); // or through a constructor

var anywhere (at the end, if(false),..) in a function makes the variable local

Array() same as new Array()
Date() different from new Date() (str vs object)

behaviour of str.match (type of value returned) depends on a flag of the regExp (g global)

return in an executor (new Promise(xxx)) does nothing (does not turn the promise into a fulfilled promise)
yet return in handler does
yet throw in handler does settle the promise into a rejected one

(node) use strict or not depending on an external package.json file

todo
https://github.com/goldbergyoni/javascript-testing-best-practices/blob/master/readme-fr.md

weird comparison rules
	https://javascript.info/comparison

srcset (image resolution switching)


standard
last published:
https://www.ecma-international.org/publications/standards/Ecma-262.htm
includes proposals:
https://tc39.es/ecma262/
https://github.com/tc39/proposals
unit test: mocha, jest

courses:
https://javascript.info/
https://developer.mozilla.org/en-US/docs/Web/JavaScript
https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/#basic-javascript
codeacademy
https://www.theodinproject.com/paths/foundations/courses/foundations
udemy
	ES2015	https://www.udemy.com/course/the-advanced-web-developer-bootcamp/
	ES6		https://www.udemy.com/course/modern-javascript-es6-for-react-js/
nodeschool

todo
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode


npm
npm install
-g
	install globally
-D
	devDependency (develop/stest)

npm init
	create project
-y --yes
	defaults, do not prompt questions

babel
	transpiler : convert modern js into js that can be run on older js engines
	to be combined with a polyfill

"use strict";
Introduced in EC5 (2009), backward incompatible changes
at beginning of script
at beginning of function
automatically enabled by modules and classes?
! node : if package.json has "type": "module" code executed strictly even if no "use strict", class,... !

;
always ; recommended


==
	does type conversion
	if number + a string/boolean => the string/boolean converted to number
===
	no type conversion
	different type => different

Object.is(a, b)
	like === but
	NaN is NaN
	+0 is not -0
	

primitive types (singlue value, stored as value in variables)
string
number
bigint
boolean
symbol
null
undefined

Object type
	{}
	function
	array
	Map
	...

String, Number, Boolean, Symbol
	allow calling methods on primitive types
	eg aString.toUpperCase(), aNumber.toFixed(2)
	as if the js Engine created a temporary object wrapper around the primitive to allow an operation to carry out.

new Number(0)
new Boolean(false)
	create a wrapper object
	NEVER USE !!!
	awful:
		typeof is object
		considered truthy (like all objects)!!
			if(new Boolean(false)) console.log("this will print!")
			if(new Number(0)) console.log("this will print!")
	Number("123") ok : returns primitive

typeof
	return string of the type

true/false	'boolean'
null		'object'	!
[]			'object'	!
{}			'object'
function() {}	'function'
() => none	'function'
class Foo{}	'function'
1			'number'
1n			'bigint'
Symbol("a")	'symbol


null
	no value, unknown, empty
	x = null; makes sense
	Number(null) === 0

undefined
	value not assigned
	x = undefined; to avoid
	Number(undefined) === NaN

null == undefined
	this is a special rule
	(eg. [] != {})



--- Number ---
numbers are double
0.1 + 0.2 == 0.30000000000000004
Number.MIN_SAFE_INTEGER
Number.MAX_SAFE_INTEGER
	around 10**15, 2^53-1
	Number.MAX_SAFE_INTEGER +1 === Number.MAX_SAFE_INTEGER + 2

1_000_000_000
1e3 === 1000
1e2 === 100
1e1 === 10
1e0 === 1
1e-1=== 0.1

0xff
	hexa

0b01111111
	binary


0o10
	octal

010	
use strict : 	 error
non use strict : === 8, but Number("010") === 10

Number(<something>)
+a_string
	convert to number (eg. a string)

new Number(12) !== 12 
typeof 12 => number
typeof new Number(12) => object
!!0 => false
!!new Number(O) => true

but Number(0) is the same as 0

parseInt(str)
parseInt(str, radix) // default 10
parseFloat(str)
	convert to number
	ignore non-number text at the end of the string
	Number("123x") === NaN
	parseInt("123x") === 123

Infinity
	obtained with the keyword or dividing by zero (except 0/0, Infinity/Infinity,..)
	
Nan
	cannot parse a number ParseInt(), Number()
	string + operation "foo" / 2


aNumber.toString()
aNumber.toString(2) // base

2.toString() // error
(2).toString() 2..toString() // ok


BigInt
	represents integer of any size
	! fairly recent (Safari 2020)
	BigInt(1)
	BigInt("1")
	1n 				// BigInt literal
	BigInt(1) + 1	// NO
	BigInt(1) == 1	// yes (also <, <=,...)
	BigInt(1) === 1 // false
	
	can use * + / < > ...
	/ rounds toward zero
	cannot use with Math.xxx, +aBigInt
	


bitwise operators
AND ( & )
OR ( | )
XOR ( ^ )
NOT ( ~ )
LEFT SHIFT ( << )
RIGHT SHIFT ( >> )
ZERO-FILL RIGHT SHIFT ( >>> )
numbers are converted to signed 32 bits integers. Truncated if needed


logical operators
|| && ! ??
	if operand is not a boolean
		convert to boolean to evaluate if true/false
		if operand is returned (see below): returns the original value (not converted)
|| || || ...
	return first true value
	or last value
&& && && ...
	return first false value
	or first value

a ?? b
	nullish coalescing operator
	nullish = null or undefined ( https://developer.mozilla.org/en-US/docs/Glossary/Nullish )
	if a not null or undefined: returns a
	if a null or undefined: 	returns b
	fairly new (2020)
	useful to give a default value if something may not be defined
		alert(user ?? "Anonymous");

a?.b
	optional chaining
	the object on the left may not exist
	if a is nullish (null/undefined) return undefined
	if a exists returns value of b (which can be undefined)
	permits: a?.b?.c
	a && a.b && a.b.c is similar but
		more verbose
		if falsish value : return falsish value instead of undefined
	the variable a must exist (but may be null/undefined) otherwhise exception
object.function?.()
	calls the function if it exists
	returns undefined if it does not exist
object?.[key]
array?.[i]
	read if object/array exists, otherwise returns undefined
delete obj?.value
	delete obj.value if obj exists
a_null_variable?.name = "John";
	SyntaxError (cannot do what amounts to undefined = "x");



--- String ---

"13"[0] === "1"
"13".charAt(0) === "1"		// was the only way originally
"hell".length === 4

"ba" < "bar"
	lexicographical order
	uppercase before lowercase  (cf ASCII table)
	diacritical marks after non diacritical marks (z < รถ) (cf unicode)
	str.localeCompare to be language aware

`template literal ${expression}`
	${} = literal
`multi
	line`
	multiline (return and newline part of the string)

a_function`tagged template literal`
	call a_function passing the strings and ${} to it
foo`tagged ${"hi"}template literal ${1+1} hi`
same as : foo([ 'tagged ', 'template literal ', ' hi' ], 'hi', 2)

String(something)
	convert to string

str.localeCompare(otherString)
	compare with locale awareness. Eg. ร < P

str.toUpperCase()

str.indexOf(searchedString, fromIndex)
	returns index
	-1 if not found
	! careful:  if(str.indexOf(...)) <== wrong (fails on -1, 0) use includes instead
	negative index like 0

str.includes(searchedString, fromIndex)
	returns true/false


"oh hello".substring(3, 7)
	returns substring
	from, to (excluded)
	can ommit to
	negative index like 0
	if from > to => swaps index

str.slice(startI, endI)
	modern version of substring.
	similar:
	returns substring
	endI excluded
	can ommit endI
	different:
	negative index counts from end of string (-1 = last index)
	if start > end => empty

str.substr(startI, length)
	negative index counts from end of string (-1 = last index)

str.split(', ')
	turn string into array based on the delimiter



--- Symbol ---
Unique identifier
NOT like string
NOT like smalltalk's #symbol


Symbol("a") != Symbol("a")
	each symbol is unique
	even if same description
	(exception see global registry Symbol.for)

alert(Symbol("hi"))
"My symbol is " + Symbol("hi")
	TypeError, symbols do not auto convert to string

Usage 1:
if use a symbol as a key (obj[symbol]) on object,
since no one else can generate the same symbol
we can have "hidden" private properties (cf Van Roy)
o[s] = "pseudo private value"
	s won't show up in
		for loop
		Object.keys()
	but will show up in the String(o)
not quite true in reality, can get the "private" symbols used as keys of an obj:
	Object.getOwnPropertySymbols(o) returns the symbols of an object
	Reflect.ownKeys(o); returns all the keys (including symbols) of an object

Object.assign WILL copy the symbolic properties

String(Symbol("x"))
Symbol("x").toString()
	convert to string 'Symbol("id")' manually

Symbol("desc").description == "desc"
	gets the (string) description

Symbol.for('x')
	global registry of symbol
	Symbols in the registry are called global symbols
	create new or return existing symbol
	Symbol.for("x") == Symbol.for("x")
	Symbol("x") != Symbol.for("x")
	similar to smalltalk's #symbol

Symbol.keyFor(some_symbol)
	returns the description of a global symbol
	pointless : can use some_symbol.description
	can be used to determine if a symbol is global or not

Usage 2:
There are "system symbols" used by javascript implementation, defined in the js specs and used by some algorithms of the language:
Symbol.hasInstance, Symbol.iterator, Symbol.toPrimitive,...
Can alter the built-in behaviour:
- make an object iterable (we choose the returned elements)
- ...



--- variables ---


var x = 0;
var x = 0, y = 1;
	set variable
	function (or global) scope (visible in the rest of the function)
var x;
	var has the value undefined
	different from x not being defined

function foo(){
    x = 1 //local, despite the later var x 
    var x;// same with if(false){var x;}
}
foo();
console.log(x) // x is not defined
	a declaration of a variable _anywhere_ with var is enough to make it  a local/function scoped variable

x = 0;
	global var
	error in strict mode

let a = 12;
	block scope
	if executed in global scope, does NOT set a property on global object (window)

let a = 12;
let a = 11;
	error, can't declare a variable twice

for(let i = 0; i < 3 ; i++) {
    arr.push(function foo(){
        console.log(i); //i different with let. Would be the same xith var
    });
}

const a = 12;
a = 11; // error
	block scope
	cannot reassign
	must assign a value;

function foo(){}
	hoisted
	in strict mode : function definition is block scoped : exists only within the block
	in non-strict mode : function scoped

variable name
	first character:  letter, $, _
	other characters: number, letter, $, _
	case sensitive
	there are reserved names (strict mode)
	camel case
	uppercase + _ for constant


,
	lower precedence than =
	evaluate expr to the left of , 
	evaluate expr to the right of , 
	return result of right/last one
	commonly used when assigning value (variables creation, for loop)



-- Array ---
['hi', 1, true]
new Array('hi', 1, true);
	rarely used (more verbose than array literal)
	if single argument of type number : create an array of that size!
array is an object with extra stuff (length, managing the ordered collection)
can be sparse
	a = [];
	a[10] = null;
	a.length === 11
	or
	Array(11)
	! some operations do not work on sparse array
		let a = Array(3)
		Array(3).map((_, i) => i);			// does nothing, no iteration
		Array(3).fill().map((_, i) => i);	// works
fill(value)
	fill array with value
fill(value, start, end)
	determine the part of the array to fill
	doesn't add elements if start/end outside the size of the array
	accepts negative value

== on two arrays is always false unless it is the same array (like all objects)
delete array[i]
	sets element to undefined
Array.isArray
	typeof [] is 'object'
	this allows to tell if something is an array
push(elem);
push(elem, elem2);
	add to the right
unshift(first)
unshift(first, second)
	add to the left
pop()
	remove last
shift()
	remove first
.length
	last index + 1
	writable!
[1, "hi"].join(", ");
	"1, hi"
	see also str.split
slice(from_i, [to_i])
	returns new subarray with elements
	does not modify the array
splice(start, deleteCount, item1, item2, itemN)
	-remove items
	-remove and add items
	-add items (deleteCount = 0)
	in place
	returns removed elements
arr.concat(arg1, arg2)
	does not change arr
	returns new array with arr concatenated to arg1, arg2,..
	args can be array or single elements
	if arg is an object with a [Symbol.isConcatSpreadable] property then all the property values of that object will be added to the result (instead of the object itself)
indexOf(item, from)
lastIndexOf(item, from)
includes(item, from)
	search for element. Uses ===
some
every
flat
flatMap
find(fn)
	returns undefined or the first match
	fn = function(item, index, array){}
findIndex(fn)
	like find but returns the index
filter(fn)
	returns array of all matching
map(fn)

reduce(fnWithAcc, optionalInitialValue)
sort(compareFn)
	sorts in place
	!! if no compareFn => sorted as string
		[1, 2, 15].sort() => [1, 15, 2]!
	compareFn(a, b) returns positive/zero/negative number
reverse()
	in place
	
a_function(...array)
	= a_function(array[0], array[1], array[2]);
	spread operator

for(let value of array){}
	iterate
forEach(function(item, index, array){})

let arr = 'hello over there'.split(' ')
let  [a, , b] = arr
	array destructuring
	any iterable on the right side



-- Iterable ---
Symbol.iterator property is a function returning an object with next()
can be used in for..of

objectThatMustBeIterable[Symbol.iterator] = function() {
    return {
        next() {
            return {done: false, value: this.current++};
            return {done: true};
        }
    };
};

can simplify with a generator function : 
objectThatMustBeIterable[Symbol.iterator] = function*() {
    yield 1;
    yield 2;
}
or just
let o = {
    *[Symbol.iterator](){
        yield 1;
        yield 2;
    }
};


Can make a self-iterable
range[Symbol.iterator] = function() {
    return this;
}
range.next = function() {
    return {done: false, value: xxx};
    return {done: true};
};
	downside : only one iteration possible

Manually interacting :
    iterator = iterable[Symbol.iterator]();
    while(true){
        let result = iterator.next();
        if(result.done) break;
        console.log(result.value)
    }



-- Asynchronous iterable ---
get elements one by one asynchronously
= iterable + promise
like normal iterable but:
- [Symbol.asyncIterator] 			instead of [Symbol.iterator]
- next() must return a promise 		instead of any value
  (next can be await to simplify)
- for await..of 					instead of for..of

let range = {
    from: 1,
    to: 5,

    [Symbol.asyncIterator]() {
        return {
            current: this.from,
            to: this.to,

            next() {
                return new Promise(resolve=>{
                    if(this.current >= this.to){
                        resolve({done: true});
                        return;//?
                    }
                    setTimeout(()=>{
                        resolve({done: false, value: this.current++})
                    }, 500);
                });
            }
        };
    }
}
	can simplify with async generator

can use async generator to make async iterable
= iterable + promise + generator

let range = {
  from: 1,
  to: 5,

  // this line is same as [Symbol.asyncIterator]: async function*() {
  // async to return Promise
  // * to handle the iteration
  async *[Symbol.asyncIterator]() {
    for(let value = this.from; value <= this.to; value++) {

      // make a pause between values, wait for something
      await new Promise(resolve => setTimeout(resolve, 1000));

      yield value;
    }
  }
};
for await (let value of range)console.log(value);



Array like object
	an object with keys: 0, 1, 2,... and length

Array.from(arrayLike)
Array.from(iterable)
	returns an object which behaves like an array:
		all the methods (push,...)
		for..of
		indexed access
	works on non array-like/iterable : as if the object was an empty array
[...anIterable]
	creates array from iterable

[a, b, ...rest] = anIterable
	destructuring
[a="default", b="default", ...rest] = anIterable
	can provide default value

similar exists for objects : {...obj}


--- Map ---
{key:0, "k":0}
	creates an object
	looks like a dictionary but isn't : 
		is an object
		default keys
		keys are string (or symbol) only
		no size attribute
use new Map() for a real dictionary type
	allows keys of any type

can have object as key

key does not have to be readonly
no equality/hash operator overloading
comparisoin based on identity

m = new Map();
m = new Map([ ['k', 'v'], ['k2', 'v2']])
m = new Map(Object.entries(obj))
set(key, value)
	can chain
get(key)
has(key)
delete(key)
clear()
size

Object.fromEntries(map)
	makes a plain object from a map object
	map = iterable/array like
	can use Object.entries(o) as source

for(let v of m)
	iterate on entries [key, value]
for(let v of m.keys())
for(let v of m.values())
forEach( (value, key, map) => ...)

WeakMap
	like map but
		key must be an object
		removed automatically if object has no other reference
		typical use : 
		-add info to an object belonging to other code. Do not want to modify the object itself but still want associated data
		- cache the result of a computation (for a given object)
	no size
	no iteration

-- set --
new Set()
new Set(iterable)
add(value)
delete(value)
has(value)	// NOT in
clear()
size

for(let v of m)
for(let v of m.keys()) //useless
for(let v of m.values()) // for compat with map, same as keys
for(let v of m.entries()) // for compat with map : [value, value]
forEach((value, valueAgain, set) => ...)
	works on Map, Set, Array
	note : also exists Object.keys, Object.values, Object.entries for objects (different from functions here)

WeakSet
	only contains objects
	no size
	no iteration
	does contain has, delete
	can determine if an element is or is not in the set
	eg.: message has been read if is in the set.



if(x){
    console.log("yup");
}else if(true) {
    console.log("nope");
}else{
    console.log("nope")
}

if(variable = xxx) yyy;
	assign xxx to variable

if("hi") true
	converts content of () into a boolean value
	
true ? 1 : 2;
	ternary operator

v = 'a';
switch(v){
    case 'a':
        console.log("this is a");
        break;
    case 'A':
        console.log("this is A");
        break;
    default:
        console.log("other");
        break;
}


while(x > 0) {...}
do { ... } while(x > 0)

outer: for(let i = 0; i < 10; i++) {
    for(let j = 0; j < 3 ; j++) {
        console.log(i, j);
        break outer;
    }
}
	can break of outer loop by giving a label

for(let x = 0; x < 2; x++){};
for(let x in obj){};
	enumerable property names of objects (enumerable: true in descriptor)
	included enumerable inherited properties
	order of iteration
		if key is string : order of property creation
		if key is string representing non negative integers:
			sorted integers first
			then other strings
			0, 1, 2, ... => integer properties
			-1, +2, ...  => NOT integer properties (sorted as string)
		(I imagine it is useful if iterate over an array, obsolete : nowadays would use for...of)
	iterate on
		object	(x are the Enumerable keys)
		array	(prefer the use of for..of)
		Map		(prefer the use of for..of)
		NOT string (works but keys: 0, 1, 2,... prefer the use of for..of)
	it's a weird choice to enumerator object (outside debugging?)
	hasOwnProperty()
		exclude properties of prototypes
		builtin properties (of Object) already ignored
for(let x of iterable){};
	iterate on iterable objects
	iterable[Symbol.iterator] magic behind the scene
	iterate on
		array
		string
		Map
		Set
		NodeList (document.querySelectorAll)
		Object.entries/keys/values(an_object) to iterate over objects
forEach
a.forEach(elem => console.log(elem));
a.forEach((elem, index) => console.log(elem, index));
a.forEach((elem, index, array) => console.log(elem, index, array));
	for arrays



-- Date --
Date and time
important:
	use FullYear NOT year
	month : 0-based (0 = january)
	day: use getDate NOT getDay
	getDay : day in the week, 0-based (0=sunday)
	timestamp are in ms, not s as is more common
	autocorrection when date is out of range
	by default values are set/returned relative to current timestamp
	can set/get values relative to utc with UTC variant of methods

new Date()
	current date/time
Date()
	current date as a string!
new Date(existingDate)
new Date(ms_since_1_1_1970)
	date.getTime() to get the timestamp
	date can be before 1970 => negative timestamp value
new Date("2017-01-26")
new Date("2017-01-26 01:02:59")
new Date("YYYY-MM-DDTHH:mm:ss.sssZ")
	or Date.parse(str)
	Z is the time zone
		Z = UTC+0
		+-hh:mm
		(time will be set relative to that timezone, the created date will be displayed relative to the local timezone)
new Date(year, month, date, hours, minutes, seconds, ms)
	month: 0 = jan
uses local time zone

getTime
	returns the timestamp
Date.now()
	returns current timestamp
	shortcut for new Date().getTime()

getFullYear
getMonth // 0-11, 0 = january !
getDate // day in the current month !
getHours getMinutes getSeconds getMilliseconds
getDay
	day of the week 0=sunday, 6=saturday
getYear
	do NOT use
	weird value

variations of above methods:
setxxx
	set the value
	Date objects are mutable
setUTCxxx
	sets the value relative to UTC. Date object remains in local time
	setUTCHour(22) and local timezone at T+1? => getHours() will be 23
getUTCxxx
	(add UTC)
	value relative to UTC instead of local time
getTimezoneOffset
	difference in minutes between local timezone (timezone used in the date object) and UTC

autocorrection
if create a date/set a value too big/too small
	will auto adjust
	new Date(2000, 0, 32) => date will be in february
useful :
	set the date to x seconds after the date : date.setSeconds(date.getSeconds()+x);
	set the date to the last day of the previous month : setDate(0)
double edged : can give wrong value and there won't be an error

conversion to primitive (number timestamp)
+aDate
	converts date to timestamp (see primitive conversion)
aDate - anotherDate
	difference in timestamp => difference in ms



--- function ---

a function with no return value or no return
	returns undefined

function foo(){}
	function declaration

const foo = function(){}
	function expression

const foo = function bar(){}
	named function expression

const func = new Function('arg1', 'return arg1 + 1;')
	new Function syntax to create a function from string
	not to be confused with object creation through constructor call
	no access to variables available in the environment where new Function is called

(function() {
    //...
})();
	IIFE
	Immediately Invoked Function Expression
	not too useful anymore can be replaced in most situation with a block {}
	case where still useful : 
	- want to assign the result of a calculation to a const
	  const foo = (function(){...return x;})();


Arrow function
() => { return 2 }
() => 2
x => { return x; }
x => x
(x,y) => { return x+y; }
(x,y) => x+y
	lambda

arrow function don't have their own this
this comes from the context!
Useful and intuitive when create an arrow function within a function



a();
function a() {console.log("a");}
	function declaration
	call before definition ok (hoisting)

b();
b = function() {console.log("b");};
	function expression
	ko : b doesn't exist at the moment of the call

c();
c = () => console.log("c!");
c = one_param => console.log("c!");	// no ()
c = (p1, p2) => console.log("c!");
c = (p1, p2) => {console.log("c!"); ... };
	ko : c doesn't exist at the moment of the call


default parameter
function foo(param=[]){
    param.push("hi");
    console.log(param);
}
foo(); // no arg
foo(undefined); 
	default parameter used if no arg passed OR undefined passed!
	(but default NOT used if null)
	default parameter evaluated each call
		opposite of python where it is evaluated once
		risk of modifying a default arg and affecting subsequent calls does not exist



a_function(...array)
	rest parameters
	= a_function(array[0], array[1], array[2]);
[1, 2, ...array]
	spread operator


function foo(...array)
	rest parameters
	array is a regular array

Math.max(...array)
	largest value in an array
	string converted to number
	other value : returns NaN

arguments
	within a function : the arguments passed
	arrow functions don't have their own arguments (it is the one of the parent function)
	array-like, iterable but does not an array : does not support array function
theFunction(...args){}
	alternative to arguments
	real array


a function is an object. It can have properties
name
	name of the object
foo = function() {} //foo.name === "foo"
obj.prop = function() {} //obj.prop.name === "prop"
	contextual name
	if no name : uses name of variable it is assigned to!
array.push(function(){}); //array.pop().name === "" got em!

length
	number of parameters



--- generator ---
function* gen() {
	yield 1;
	yield 2;
}
function *gen() {} // also works but not used

returns a generator object which has a next() method that returns { value:x, done:y} objects
lazily executed : function doesn't start until next() of generator object is called

values returned by successive next(): 
eg.: yield 1; yield2;
{ value: 1, done: false }
{ value: 2, done: false }
{ value: undefined, done: true }

eg.: yield 1; return 2;
{ value: 1, done: false }
{ value: 2, done: true } // won't appear in a for..of
{ value: undefined, done: true }
	return value does not show up in for..of!

cannot call yield from a function or arrow function

throwing an exception in the generator throws the exception in the caller

function* generateSequences() {
    yield* generator(0, 10);
    yield* [10, 11, 12];
}
	generator composition
	works with generator and iterable

function* gen() {
    let valueFromSecondNext = yield "first yield value";
    console.log(valueFromSecondNext); // "value passed to first yield"
}
let g = gen();
// do not pass value to first next
console.log(g.next()); // { value: "first yield value", done: false }
console.log(g.next("value passed to first yield"));  

g.throw(new Error("msg"));
	can pass exceptions
	if exception isn't caught in the generator it is thrown (back) in the caller

g.return(value);
	stops the generator (done is true from now on)
	value will be the value of the object returned by next()

can emulate generator with a function returning a function:
function pseudoGen() {
  let value = 0;
  return function() {
    return value++;
  }
}
let g = pseudoGen();
g();
but will not have the nice features: for..of, yield*, g.return,...


--- async generator ---
1)
//async simplifies use of Promise
async function async(){
    return 1;
}
async().then(resolve => {
    console.log(resolve);
})
console.log(await async());


2)
//generator function simplifies iteration (Symbol.iterator)
function* gen() {
    yield 1
    yield 2
}
for(let v of gen())console.log(v);


1+2 = 
//async generator = async + generator
async function* asyncGen() {
    yield 1;
    await new Promise(resolve => setTimeout(resolve, 1000))
    yield 2;
}
for await(let v of asyncGen())console.log(v);
result = await genOjbect.next()



-- Callback --
//simple callback
aFunction(..., function(value){
});

//callback with error
aFunction(..., function(error, value){
	//no error : error null, value
	//error:	 error, no value
});

to avoid callback hell:
- put into separate (top-level) functions instead of imbricating
  inconvenient : have to jump around the various functions to follow execution
- promise



-- Promise --
new Promise(executorFunction);
let aPromise = new Promise(function(resolve, reject){ // executor function
	... // usually some asynchronous work
	// single argument
    resolve(1);
    return x; // NO! does not settle the promise
    
    // recommend returning an Error object (like throw)
    // alternative : throw
    reject(new Error("error x")); 
})
the executor function is run immediately (before returning the promise object)

only the first resolve/reject has an impact on the listeners

if return in the executor : handlers will never run, promise will never settle

promise has a (internal, hidden) state : pending or settled(fulfilled/rejected)

when there is a reject : the closest reject block catches it (catch or then(null,xxx).

a throw xxx in executor or a handler turns the result into a reject

Can create custom "thenable" object : an object with a then function
	can be returned by a handler
	will be treated like a native promise.
	allows objects that can be used with the promise system without having them inherit from Promise
let thenable = {
    then(resolve, reject) {
        resolve(2);
    }
}
	typically they would be a full type created with a class or constructor

handling promise result
then()/catch()/finally()
	blocking
	can call multiple time on the same object(multiple subscribers)
	can chain
	they return a new Promise object each time

.then()
	if there is a chain: must return a value otherwise next handler will see undefined!!!
	can return a new Promise object or a value (will turn into a promise)
.catch()
.finally()

	
aPromise.then(function(result){
    // onfulfilled
    console.log("fulfilled: " + result)
},
function(error){
    // onrejected
    console.log("rejected: " + error)
});


aPromise.catch(function(error){
    console.log(error);
})
same as:
aPromise.then(null, f);

aPromise.finally(function(){
	// no arg
	// for cleanup
})


if a rejection promise is unhandled it is printed in the console.
Can catch them:
window.addEventListener('unhandledrejection', function(event) {
  // the event object has two special properties:
  alert(event.promise); // [object Promise] - the promise that generated the error
  alert(event.reason); // Error: Whoops! - the unhandled error object
});

process.on("unhandledRejection", function(reason, promise){
    console.log("!!!", reason, promise);
})


Promise.all
	arg = array/iterable of promises
		there can be regular values in the iterable as well
	then : arg is an array (same size/order as the arg)
	if rejection : first rejection is passed (others are ignored)

Promise.allSettled
	arg = array/iterable of promises
	then : arg is an array of :
		{ status: 'fulfilled', value: 1 },
		{ status: 'rejected', reason: [Error: err msg] }
	waits for all the promises to be settled

Promise.race
	arg = array/iterable of promises
	returns the first settled promise

Promise.any
	arg = array/iterable of promises
	returns the first fulfilled promise
	if all are rejected : returns an AggregateError containing an errors array

Promise.resolve(value)
	creates a resolved promise from the passed value

Promise.reject(error)
	creates a rejected promise from the passed value


promisification : turn a function accepting a callback into a function returning a promise

fetchFromAPI : callback has two parameters: error, value
function fetchFromAPIPromise(name) {
    return new Promise((resolve, reject) => {
        fetchFromAPI(name, (error, result) => {
            if(error) reject(error);
            else resolve(result);
        });
    });
}

fetchFromAPI : callback has single parameter: value (no error)
function fetchFromAPIPromise(name) {
    return new Promise((resolve, reject) => {
        fetchFromAPI(name, resolve);
    });
}




--- async await ---
async
async function f() {
    return 1;
}
	the function always return a Promise
	return value wrapped in a resolved promise
	or thrown exception wrapped in a rejection promise
like:
function f() {
	return Promise.resolve(1);
}

async function f() {
  throw new Error("msg");
}
like:
async function f() {
  return await Promise.reject(new Error("msg"));
}

await
let result = await f();
let result = await aPromise;
blocks until the promise is settled then returns the value
only works inside async functions 
works globally (not always?)
works on thenable objects

handle rejection:
try{
    let v = await p2;
}catch(err){
    console.log(err);
}


--- OO ---

{}
	object initializer
	aka object literal
	keys converted to string

a.key
a["key"]
	get value of key

{
  [a_var]:1; //any expression really
}
	computed property
	Take the value, use its string representation as the key

name = "John";
{
  name // equivalent to name: name
}
	property value shorthand
	result : Object { name: "John" }

obj = {
  shorthandMethod(){ // equivalent to shorthandMethod: function() {
    ...
  }
}
	method definition shorthand
	! contrary to the long form cannot be used as a constructor ??? why
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#method_definitions


obj.key = x;
obj["key"] = x;

"property_name" in obj
	test if the property exists
	almost like obj.property_name !== undefined but returns true if we stored undefined in property_name

delete object.property
delete object["property"]
	removes key from object

object converted to boolean : always true

Object.keys()
Object.values()
Object.entries()
	return arrays (contrary to map.xxx, set.xxx, Array.xxx which return an iterable)
	do not appear:
		symbols
		properties with flag writable: false
		properties from prototype
	(can get them with Reflect.ownKeys())

for(let [key, value] of Object.entries(obj)){}



-- Properties --
property attributes : value + flags
property flags:
writable		read-only or not?	
enumerable		appear in loops
configurable	can be deleted, flags can be changed
a normal property : 3 flags true

for a getter/setter property:
get
set
enumerable
configurable

writable: false
	write non strict : nothing happens
	write strict: error

configurable: false
	prevents property from being deleted
	cannot change flags/value (EXCEPTION : can set writable to false)
	often combined with writable false otherwise can set writable back to true with Object.defineProperty


property descriptor : object describing a property (configurable, enumerable,...)
{value:x, writable: true, enumerable: true, configurable: true}
	descriptor for a data descriptor
{get: function(){}, set: function(v){}, enumerable: true, configurable: true}
	descriptor for a accessor property

Object.getOwnPropertyDescriptor(obj, propertyName)
	returns a property descriptor : value + flags

Object.getOwnPropertyDescriptors(obj)
	get proprety descriptors for all properties
	returns an object: {propertyName: {propertyDescriptor}, ...}
		same object structure as in defineProperties

Object.defineProperty(obj, propertyName, descriptor)
	sets attribute
	eg. Object.defineProperty(o, "a", {value: "hello", enumerable:false})
	if creates a new property: missing flags are assumed false




Object.defineProperties(obj, {
	prop1: {...},
	prop2: {...},
})
	same object structure as in getOwnPropertyDescriptors

Object.getOwnPropertySymbols(o)
	get all Symbol properties
Reflect.ownKeys(o)
	all the keys (string and symbols)

Object.isExtensible(obj)
Object.preventExtensions(obj);
	cannot add new properties
	
Object.isSealed(obj)
Object.seal(obj);
	cannot add/remove properties.
	Sets configurable: false on all properties
	
Object.isFrozen(obj)
Object.freeze(obj)
	cannot add/remove/change any property.
	Sets configurable: false, writable: false on all properties



data property : usual property
accessor property : property with a getter/setter method behind it.

let obj = {
  get propName() {
    // getter, the code executed on getting obj.propName
  },

  set propName(value) {
    // setter, the code executed on setting obj.propName = value
  }
};

Create an accessor property with an accessor descriptor:
Object.defineProperty(object, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  },
  //enumerable, configureble..
});

to have a "private" backing field for a property:
_privateProperty



-- Object destructuring --
o = {
    a: "aa", 
    b: "bb",
    1: "one value",
}
let {a, b, 1: one} = o;
a === "aa"
b === "bb"
one === "one value" //variable name different from the key
	destructuring objects
	extract values of properties and put them in variables
let {width: w = 100, height: h = 200, title} = options;
	with default value

can have multiple levels
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};
// destructuring assignment split in multiple lines for clarity
let {
  size: { // put size here
    width,
    height
  },
  items: [item1, item2], // assign items here
  title = "Menu" // not present in the object (default value is used)
} = options;

let options = {
    title: "title", 
    items: [1]
}
function manyArgs({title = "default", items = [],...} = {}){}
manyArgs(options)
	can use on parameters


the way the function is called determines if it is:
	- a function (this not attached to object but global/undefined)
	- a method (this = object)
	(except if used bind)
this is the opposite of python and many languages where this in a method is always bound to an object
a = {
    attr: 0,
    func: function() {
        return this;
    }
}
a.func(); // this = a
f = a.func
b = f() // this = global object

Can take any function and attach it as an attribute to the object : 'this' will be the object if called through the object (exception bind)
a.fn = some_random_function

a_function.call(this_object, 0, 1);
	calls the function with a certain this object and arguments
a_function.apply(this_object, [0, 1]);
	same but args is an array
	can be used to splat an array:
	a = [0, 1, 2]
	Math.min.apply(Math, a); // array converted to individual arguments

bind(thisObject, arg1, arg2)
	return a new function whose this is _permanently_ attached to thisObject
	and the first arguments always are the ones specified (arg1, arg2)
	returnedFunction() ~= originalFunction.call(thisObject, 0, 1);
	call to bind does not affect the original function
	stronger than call, apply, an_obj.bound_function()! => this won't change
	cannot rebind
	useful for setTimeout(object.method) => can avoid losing object being this with bind
	the new function does NOT have the properties of the original

bind(null)
	bind to the global object

if call a function without an object, this:
	- non strict: 	global object
	- strict: 		undefined



-- Constructor --
new aFunction()
	aFunction is (used as) a Constructor
	creates a new object, within the function 'this' is that object
	that object is returned
	BUT if return a object (type object only, no primitive) : will be the object returned
	aFunction() {...; return {};}
		{} will be the object created
	aFunction() {...; return "4";}
		not a valid object, the created "this object" will be returned
	if no argument, can omit the () : new aFunction <=> new aFunction()

var Constructor = function() {
    this.x = "x";	//within it, this is the new object which will be returned
};
o = new Constructor(); // new object
o.x === "x"

immediately called constructor
let user = new function(){
	this.x = ...
	...
};
	immediately called constructor function
	wrap object creation related code in a single place

new.target
	within the function
	if not called with new :	undefined
	if called with new :		= the function



-- Prototype --
object have prototype
prototype can itself have a prototype
attribute access looks up the prototype chain

myobj = Object.create(aPrototype);
	associate a new object with a prototype
	aPrototype can be null (avoid default keys if we use it as a map)
myobj = Object.create(aPrototype, propertiesObject);
	propertiesObject, same as Object.defineProperties
or
function Constructor() {}
Constructor.prototype = {
    number: 5,
    getNumber: function() {
        return this.number;
    }
}

Object.setPrototypeOf
Object.getPrototypeOf(anObject)
	gets/sets prototype of an object
anObject.__proto__
	deprecated
	dangerous to have : people use user supplied values as keys


AConstructor.prototype
aDefaultPrototype.constructor
anObject.constructor
	because of the constructor property on its prototype.

AConstructor.prototype = {};
	!changing the default prototype
	the constructor property on the new prototype object won't point to
	AConstructor
	{}.constructor = Object and not AConstructor
	solution:
	- add properties to the default prototype
	- 	


-- Prototype inheritance --
'this' in the method of a descriptor in a prototype is the child object
proto = {
  foo: function(){return this} // child.foo() : this === child
}
child = Object.create(proto);
child.foo(); //left part of the . dictated the this

writing on an object doesn't affect the prototype
proto : {a:1}, obj: {} (+its prototype is proto)
obj.a = 666;
proto : {a:1}, obj: {a: 666}

deleting on an object doesn't affect the prototype
proto : {a:1}, obj: {} (+its prototype is proto)
delete obj.a;
proto : {a:1}, obj: {} // no effect on the prototype

exception : accessor descriptor (get/set) in the prototype
reading/writing such property is actually a method call:
obj.accessor = 1;
actually does something like:
protoOfObj.getAccessor(1)
BUT this in the method is the object called and not the prototype

let proto = {
    get a() {
        return this._a; // this is child
    },
    set a(value) {
        this._a = value; // this is child
    }
}
let child = Object.create(proto);
child.a = 666; // set a()
console.log(child.a); // get a()

let proto = {
    stomach: [],
  
    eat(food) {
      this.stomach.push(food); // calls push on stomach of proto
      this.stomach = [food]; // set stomach on obj to food
    },
    
    set eat(food) {
      this.stomach = [food]; // 
    }
  };
 
let obj = Object.create(proto);
obj.eat("apple");


Builtins (Array, Number,..) have their own prototypes
those prototypes (Array.__proto__,..) have a prototype : Object.__proto__


Number.prototype.decuple = function() {
    return this*10;
}
	can change prototype of builtins
	sometimes used for polyfilling

Object.assign(target, ...sources)
	take all the enumerable own properties of the source objects and put it into target
	returns target
	shallow clone (property values of source are copied by value)
	order important (later overwrite earlier)
	??? how are properties handled? https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#description

Array.prototype.join.call(arguments)
	method borrowing



--- class ---
class MyClass {
    constructor(name) {
        this.name = name; // in the object
        console.log("constructor")
        //like constructor function : implicit this or explicitly return object
        return {}; 
    }

    myMethod() { // in the prototype
        console.log(this.name);
        this.otherMethod(); // call another method
        return 0;
    }
    
    get name() { // in the prototype
	    return this.name;
	}
	set name() {}

	[computerName](){} // in the prototype
	
	//class field
	//class field initialized before the constructor() runs
	xyz = 123; // in the object
	[computerName] = 123; // in the object (class property)	
}
typeof MyClass === 'function'
MyClass = MyClass.prototype.constructor
	Creates a MyClass function whose body is the constructor
	put the methods in the class's prototype
	like a prototype/function based type

let MyClass = class {...}
let MyClass = class User {...} //User visible inside the class only
	class expression
	can create classes dynamically (eg. class returned by function

differences from prototype/function based:
- must call with new
	MyClass() doesn't work
- string reprensentaiton different
- methods non enumerable by default
  like an implicit : Object.defineProperty(MyClass.prototype, "myMethod", {enumerable: false});
- all code within a class uses strict


aMethod() {
    setTimeout(() => this.hide(), 1000);   // ok (arrow functions share this)
    setTimeout(function() {this.hide()}, 1000); //SyntaxError
}

static property and method : same as assigning to the class
class User {
    static xxx = "xxx";
}
User.xxx = "xxx";

static method:
class User {
    static staticMethod() {
        console.log(this === User);
    }
}
User.staticMethod();
Just like doing:
User.staticMethod = function() {
    console.log(this === User);
}
	except here staticMethod is enumerable

cannot access static fields/methods through an instance


instance instanceof classOrConstructorFunction
	goes up the prototype chain of the instance
	check if one of those prototype is the prototype of the  class or constructor
	

SomeClass.prototype = xxx
	affects instanceof! (but not the objects created before)


class A {
	static [Symbol.hasInstance](obj) {
	  // return true or false;
	}
}
xxx instanceof A // the static method will be called
	instead of using the prototype chain, the static method is used
	result of the method is the final result of instanceof. 
	if a superclass of A has an Symbol.hasInstance (and A and the classes between A and it doesn't), it will be called


[Symbol.toStringTag] =  "Xxx"
	Used by the builtin toString
	instead of [object Object] => [object Xxx]


-- protecting fields / private --
_xxx convention : private, do not touch from the outside
protect field access:
class AClass {
  _waterAmount = 0;
  set waterAmount(value) { // accessor property to protect
    if (value < 0) {
      value = 0;
    }
    this._waterAmount = value;
  }
  get waterAmount() {
    return this._waterAmount;
  }
}

read-only field:
class AClass {
	constructor(power) {
	  this._power = power;
	}
	get power() {
	  return this._power;
	}
}

private field and methods
enforced by the language itself
!! recent (2021)
!! NOT visible in subclasses!
!! cannot access through this['#name']
class AClass {
  // a private field must be declared at the class level before it can
  // be used within a a method (this.#x)
  #privateField = 0;
  #privateMethod() {}
  
  constructor() {
  	//SyntaxError exception thrown
    this.#fieldNotDeclaredAtClassLevel = "xxx";
  }
  
  // access only within the class : this.#privateField, this.#privateMethod()
}
aClassInstance.#privateField = 0; // will fail
aCLassInstance.#privateMethod();  // will fail



-- inheritance --
single inheritance only (but mixin possible)

class Rabbit extends Animal {}
	inheritance
	sets Rabbit.prototype's prototype to Animal.prototype
class AClass extends xxx {} => xxx can be anything that returns a class (function,...)

super.method()
	call method in parent

//constructor in a subclass : 
constructor(name) {
    super(name) 
    this.x = "x";
}
	must call super()
	super() must be called before using this
	reason : the object created must be the one from above (to be set up correctly prototype wise)

constructor(...args) {
    super(...args)
}
	the default constructor does this


A constructor in a class that inherits from another class must retrieve the object it will work on (and return) from the superclass's constructor
Consequences:
- must call super() (to get the object)
- The class fields of a class are only initialized after super() has been called in the constructor. (need the object before we can initialize the fields)

In a constructor the class fields of the super classes and the current class are initialized but not the one of the subclasses
class Animal {
    name = 'animal';
    roar()
    constructor() {
        console.log(this.name); //prints animal
    }
}
class Rabbit extends Animal {
    name = 'rabbit';
}

BUT the methods of the subclasses are available
class Animal {
    name = 'animal';
    say(){
        console.log(this.name)
    }
    constructor() { // 1) constructor runs
    				//    class fields of Animal initialized but NOT Lion
        this.say(); // 2) say of Lion called 
    }
}
class Lion extends Animal {
    name = 'lion';
    cry = "roars!"
    say() {
        console.log(this.name, this.cry); // 3) prints animal undefined
    }
}
new Lion()
	undefined because : 
		parent constructor calls overridden method in subclass
		class fields not yet initialized in subclass
	=> careful in constructor when calling methods!

there is some magic in methods (defined in class and plain objects) to make super() work as expected
hidden [[HomeObject]] property so that super() points to the right object (in the inheritance tree).

anotherObject.aFunction = object.aMethod;
anotherObject.aFunction()
	will break if aMethod has super()


- two [[prototype]] chains -
class Animal {}
class Rabbit extends Animal {}

Prototype chain for instances/prototype objects:
console.log(Object.getPrototypeOf(Rabbit.prototype) == Animal.prototype);
a prototype can have a prototype : the parent prototype
	makes inheritance work
	obj.xxx if not found in obj then go to obj's prototype then obj's prototype prototype...

Prototype chain for classes:
Classes have also their prototype chain!
Makes static work with inheritance
console.log(Object.getPrototypeOf(Rabbit) == Animal);

class Rabbit {}
class Rabbit extends Object{}
	difference: with extends static methods of object work on Rabbit
	eg. Rabbit.getOwnPropertyDescriptor
	because : extends sets up the prototype chain _on the classes_ (aka functions)

built-in objects (Array, Map,..) have the first chain but not the second
Object.xxx not available in Array.xxx


- built-in inheritance -
Can inherit from built-in types
class PowerArray extends Array {
	...
}

aPowerArray.filter/map/... => type of array returned will be PowerArray!
those methods check the type of the object when creating a new one

static get [Symbol.species]() {
  return Array;
}
	within a class that inherits from a built-in type
	can specify which class will be used when filter/map/... create a new object


-- mixin --
Inject behaviour into a class
let someMixin = {
  // methods here
}

class SomeClass {}
Object.assign(SomeClass.prototype, someMixin);


--- Primitive conversion ---
no operator overloading (redefine '+' operator in obj1 + obj2)
but can control (some) conversions of obj (to string/number/default)
obj->boolean : always true, NO control
	eg !obj, obj === true (but NOT obj == true which uses default), Boolean(obj)
obj->string : can control
	"string" hint
	eg alert(obj), anotherObj[obj], String(o)
	! NOT "a string" + obj
obj->number : can control
	"number" hint
	eg obj1 - obj2, Number(obj), obj1 > obj2, 0 > obj, "str" > obj
default conversion
	"default" hint
	eg obj1 + obj2, "str" + obj, if (obj == 1)
	used when not sure if number or string should be used
	in practice : all built-ins object convert to number (except date), we should do the same => treat number and default hints the same

Two ways
1. Modern
o = {
    [Symbol.toPrimitive](hint) {
        if(hint == 'string'){
            return "I am o!"
        }else{ // 'number' or 'default'
            return 0;
        }
    }
}
	Checked to see if exist first, used if exists
	must return a primitive type, error if return object

2. older
o = {
    toString(){
        return "I am o"
    },
    valueOf(){
        return 99;
    }
}
	checked if no Symbol.toPrimitive
	"string" hint : check toString then valueOf
	"number" "default" hints : check valueOf then toString
	can implement only one : eg toString
	must return primitive, result ignored if not a primitive (as if method didn't exist)

Since we can't return objects nor know which exact operation the conversion is for, the conversion system is of limited use (especially default/number).	
If want to keep things simple : 
-can implement only toString, will always be called (except boolean conversion). Good for debugging.
-States that objects not designed to perform operations on it.



alert("msg")

prompt("msg", displayed_default)
	return null if cancel

confirm("msg")
	return true or false



--- try catch ---
try {
    a;
} catch(err) {
} catch { // or
    err.name;
    err.message;
    err.stack;
    
    //typical pattern : handle what we want, rethrow the rest
    if(err instanceof SyntaxError){
    	// handle
    }else{
    	throw err;
    }
}finally {
    console.log("finally");
}
	watch out for block scope : what is declared in try isn't visible in catch/finally

throw new Error("msg")
	can technically throw anything
	should throw something inheriting from Error

try {
    return 0;
}finally {
	// return in finally takes precedence over return
	//swallows exceptions
    return 2; 
}

function MyError(message=""){
    this.name = "MyError";
    this.message = message;
}
MyError.prototype = new Error();
	custom exception
  
class FormatError extends SyntaxError {
    name = this.constructor.name;
    constructor(...params) {
        super(...params)
    }
}
	better custom exception
	can add parameters to the constructor : additional data
  
process.on("uncaughtException", function(err, origin){}
	global handler (if exception was not caught)
	node

window.onerror = function(message, url, line, col, error) {
	global handler (if exception was not caught)
	browser
	doesn't seem to work for exceptions created from the browser console
	used to send those error to an error logging service
	generally not used to show errors to user

--- Global object ---
window in browser
global in node
globalThis in browser and node (since 2019)

var foo = x;
console.log(window.foo);

global.foo = 1
console.log(foo);
	bad to put variables in the global object
	useful for polyfill



--- modules ---
Will see ES modules
other systems:
- AMD
- CommonJS (node.js default)
  require()
  default on node. 

Node:
to use ES modules in node:
- use .mjs extension
- "type": "module" in package.json

Otherwise : SyntaxError: Cannot use import statement outside a module

Browser:
to use ES modules in browser:
Must use type="module" in the <script>
<script src="a.js" type="module"></script> //
<script type="module">...</script> //

Otherwise : SyntaxError: Cannot use import statement outside a module


only runs the code of a module once, even if imported multiple times

Changes to module compared to standard script:
- a module has its own top-level scope
  (can still share data : import/export or global object)
- this is undefined in the top-level
- can import export
- a module is always in strict mode
- import.meta contains info about the module
	import.meta.url

browser specific:
- module <script> are always deferred
	asynchronous load
	runs in order before DOMContentLoaded
- defer behaviour works on inline script!
- can use async attribute on inline <script> if it is type="module"
- external <script>s for the same src url : run only once
- requires CORS if src is cross origin

bare module?

usually don't mix named and default exports


-- named export/import --
export
export function xxx(){}
export class Xxx {}
export let xxx = ...;
export const xxx = ...;
	export during declaration

...
export {sayHi, xxx};
export {xxx as yyy};
	export apart from declarations

import
import {xxx} from './module.js'
import {xxx as yyy} from './module.js'

import * as mod from './aModule.js'
	import all
	mod.xxx
	avoid:
		prevent bundler optimizations (remove unused dependencies)
		longer names
		easier to read/refactor

-- default export/import --
+ many small modules, only one thing per module easier to understand
- multiple imports can use multiple names
export default function foo(){}
export default aVariable; // cannot do export default let aVariable = 1; two lines required
export default class {}
export default 123;
	name not required for default export

export {xxx as default, yyy}


import module from './module.js'
	if export default used
	rule : 	name of variable is the name of the module
			avoids importing multiple things under different names

import * as user
	if default : user.default


-- export something we import --
useful for facade, public interface of a package
elements NOT available in current file (sayHi, User are not available)

export {sayHi} from './say.js'
	named export
export {default as User} from './user.js'
	exports the default

export * from './module.js'
	export everything named
	does not export the default
	to export default : see above

-- dynamic import --
static imports : cannot choose file name dynamically, cannot import conditionnaly
dynamic import : can choose file name, can import conditionnaly
import()
	returns a promise containing the import
import(modulePath)
  .then(obj => obj is the module object)

let {hi, bye} = await import(moduleName);

let obj = await import('./say.js');
let say = obj.default;
or:
let {default: say} = await import('./say.js');



--- eval ---
eval(code as string)

let value = eval(...)
	value is the value of the last statement

eval'ed code runs in non strict mode by default
to run in strict mode : eval("\"use strict\"; ...);

can see/set variable of the environment where eval() is called
(use variable, change them)
bad programming practice
fail with minifier

non use strict (parent code):
	can create new variables => visible in context where called

use strict (parent code):
	can create new variables => not visible in context where called
	(can still access/change existing variables)

window.eval
global.eval
	the context is the global object

function foo() {
    global.eval("aaa = 1;");
    console.log(global.aaa); // 1
    console.log(aaa); // 1
}
foo();

consider new Function(code) instead

--- JSON ---
RFC4627
a JSON string called : JSON-encoded, serialized, marshalled.
differences from object literals:
	strings are double quotes
	property keys are within quotes
	no properties with undefined value
	no function
	no Symbols
	no comments
	
JSON.stringify(value)
JSON.stringify(value, replacer)
	replacer : array of string or function
JSON.stringify(value, ["a", "b"])
	in objects only properties with these names will be encoded
JSON.stringify(value, function(key, value){})
	! first call to it will have empty key and the object passed to stringify as value
	this is the object which possess the property
	return undefined to skip property
	return a value : that value will be the one encoded
JSON.stringify(value, replacer, space)
	space
	0 = one-line compact
	1+ = on multiple lines + size of indentation

toJSON
	function attached to an object
	returns string representation
	used by stringify


JSON.parse(str)
JSON.parse(str, reviver)
	reviver is a function(key, value)
	convert the string value back into js representation
	returning undefined = do not deserialize that property
	this is the object that will be created
		includes not yet handled properties, transformed properties
		not the properties that have already been rejected for the current object
	eg: dates



--- timeout interval ---
timerId = setTimeout(func, delay, arg1, arg2,...)
timerId = setInterval(func, delay, arg1, arg2,...)
clearTimeout(timerId);

this is the window object (Timer object in node)

zero delay scheduling: delay == 0. wait for the current code to stop running before running it

careful: 
- memory leak : everything func refers to (variables outside the function) won't be GC'ed until clearTimeout has been called

- delay is NOT wait 'delay' amount of time after last execution before calling it again
	it is : call func every 'delay'
	problematic if the function is slow => short/no pause between calls
	can be fixed by  rescheduling the calls ourself with setTimeout

- can lose the this
	setTimeout(object.method, 1000)
	method will be called without the object. Wrong this.
	fix with bind



--- Regex ---
new RegExp("pattern", "flags");
/pattern/gmi

flags
i	case insensitive
g	global, all matches not just the first
m	multiline mode, ^ and $ match at beginning/end of line not just string

str.match(regexp)
	if g flag : array of matches (simple strings)
	if no g flag: array representing a single match (details on the match)
		[0] = matched, [1] first group,..
		length	number of indexes (result+groups)
		index
		input
		groups ???
	if not match: null !!! (g or no g)

str.matchAll(regexp)
	regexp must have the g flag
	returns an iterable of arrays representing a match
	returns empty array if no match

str.replace(regexp, replacement)
	if no g :	replace first
	if g: 		replace all
	replacement accepts special value which will be replaced by part of the match

aRegexp.test(string)
	is there a match

str.split(regexp)
	returns array

str.search(regexp)
	position of first match or -1









--- dev tools ---
$0 in console
	last element selected

inspect(aDOMNode)
	selects/inspects the element

console.log(DOMElement)
	shows DOM tree
console.dir(DOMElement)
	shows properties (like an object)



--- ID-named global variable ---
BAD
<div id="foo">hello</div>
<script>
    foo.textContent = "new content";
    window.foo.textContent = "new content";
</script>
    id-named global variable / variable on the window access
    Named access on the Window object
    all nodes with id are added to the window object
    (and thus globally available)
	Crazy (bad) because
	- it can clash with window's default properties
		(window's built-in properties win in that case)
	- it can clash with global variables set in js
		(global var wins in that case)
    https://stackoverflow.com/questions/3434278/do-dom-tree-elements-with-ids-become-global-variables
    https://html.spec.whatwg.org/multipage/window-object.html#named-access-on-the-window-object



--- window ---
in browsers the window object is
- the global object
- the way to control the browser

BOM Browser Object Model
represents objects to interact with the browser
(except the document itself which is the DOM).
eg.: location, navigator,...



--- DOM ---
Document Object Model
object representation of document

There also is the BOM (browser related objects)
There also is the builtin js APIs

types of nodes : 
- element node
- text node
	contains only text
	no chidren (always leaf)
- comment node
- document node (the access point)
... (12 types in all https://dom.spec.whatwg.org/#node )

putting nodes after body : automatically moved to the end of body

html and body nodes are always generated

<x>
 <y>
 	=> text node containing the newline + space between x and y!
	there are text nodes for new lines and space between elements but they are not shown in browser tools
	xxx.childNodes lists them


-- DOM objects --
                    โโโโโโโโโโโโโโโโโ
                    โ EventTarget   โ
                    โโโโโโโโฒโโโโโโโโโ
                           โ
                    โโโโโโโโดโโโโโโโโโ
       โโโโโโโโโโโโโบโ     Node      โโโโโโโโโโโโโโโโ
       โ            โโโโโโโโโโโโโโโโโ              โ
       โ                   โฒ                       โ
       โ                   โ                       โ
โโโโโโโโดโโโโโโโโโ   โโโโโโโโดโโโโโโโโโ      โโโโโโโโโดโโโโโโโโ
โ     Text      โ   โ   Element     โ      โ    Comment    โ
โโโโโโโโโโโโโโโโโ   โโโโโโโโโโโโโโโโโ      โโโโโโโโโโโโโโโโโ
                           โฒ
                           โ
                    โโโโโโโโดโโโโโโโโโ
        โโโโโโโโโโโโบโ HTMLElement   โโโโโโโโโโโโโโโโ
        โ           โโโโโโโโโโโโโโโโโ              โ
        โ                  โฒ                       โ
        โ                  โ                       โ
โโโโโโโโโดโโโโโโโโโ  โโโโโโโโดโโโโโโโโโ       โโโโโโโโดโโโโโโโโโโโ
โHTMLInputElementโ  โHTMLBodyElementโ       โHTMLAnchorElementโ
โโโโโโโโโโโโโโโโโโ  โโโโโโโโโโโโโโโโโ       โโโโโโโโโโโโโโโโโโโ

EventTarget
	addEventListener
	removeEventListener

Node
	parentNode, childNodes, firstChild,...
	nodeType
	nodeName
	textContent


Element
	tagName
	children
	nextElementSibling,...
	id
	className
	querySelector
	innerHTML
	hidden

HTMLElement

HTML<Type>Element
html attribute => DOM element property is not a one-to-one mapping



nodeType
	old school way to determine type of DOM Node
	number
	Node.ELEMENT_NODE(1), Node.TEXT_NODE(3), Node.COMMENT_NODE(9), 

nodeName
	string of the name
	always uppercase
	for any node (including text, comment,..)
tagName
	for Element
	tag as-in HTML tag
	(not on document object which is a node)


-- navigation properties --
document is the parent of
	document.doctype
	document.documentElement (html)

html is the parent of 
	document.head (shortcut)
	document.body (shortcut)

navigation attributes
from a node, access to other nodes:
parentNode
	parentElement is identical except html.parentElement is null.
	reason : document is not an element node


-- navigation methods --
xxxElementxxx means the nodes of type element only (no text, comment,...)

previousSibling previousElementSibling
nextSibling nextElementSibling

firstChild firstElementChild
lastChild lastElementChild
childNodes (all types of nodes)
children (elements nodes)

DOM collections:
coming eg. from childNodes
- not an array but iterable and indexable
- most often dynamic (changes in DOM reflected in the collection object)
  sometimes static (eg. querySelectorAll)


document.getElementbyId
(also id as global var, see below)

document/element.querySelector(cssSelector)

document/element.querySelectorAll(cssSelector)
	static list

document/element.getElementByTagName	element of a certain type (div,..)
document/element.getElementByClassName
document.getElementsByName				elements with the given value for the name attribute (not used anymore)
	these are replaced by querySelector

element.matches(cssSelector)
	does the element match the given css-selector

element.closest(cssSelector)
	nearest ancestor (including the element itself) matching the selector

element.contains(elementB)
	does element contain or is elementB


-- element properties --
innerHTML
	HTML in the element as a string
	not the HTML of the element itself
	can change the HTML content!
		xx.innerHTML = '...'
		modifies the object
		rewrites everything.
		Lose state, text input, events,..
		scripts inserted are NOT executed

outerHTML
	includes the HTML of the element itself
	can change the element
		doesn't change the content
		replaces the element with a new one!
		old object is still around but not attached
			aDiv.outerHTML = '...';
			aDiv// still here with the old content

textContent
	text inside (no tags)

nodeValue data
	for types other than Element (comment, window.document)

value
	value inputted in input, select, textarea,...

hidden
	hidden = true
		sets the [hidden] attribute on the element
	remove element from the DOM (changes layout)


-- HTMLElement properties / HTML attributes --
attributes in the html maps to properties on objects of the DOM

two ways to access the attributes set on html elements from the html object:
- through specific properties (eg. id="x" => anObj.id)
  actual value
- through attribute api below (getAttribute,..)
  value set on the HTML

value set on the HTML may not match the actual value : 
- css
- changed by js

properties may not have the same value as the attribute:
- checked: converted to boolean
- href: full URL
- value: current value set by user instead of attribute value


hasAttribute(name)
getAttribute(name)
setAttribute(name, value)
removeAttribute(name)
	case insentive name!
	value is always string

attributes
	array of attributes
	live

<... data-xxx = "...">
	custom data attribute
	add data to html elements
	alternative to classes
	guaranteed never to clash with standard properties
	typically used by javascript
	accessible from elem.dataset
	converts name : [data-abc-def] <=> dataset.abcDef



--- create / manipulate html ---
document.createElement(tagName)
document.createTextNode(text)
document.createComment(text)

node.cloneNode()
	same as cloneNode(false)
	clones a node
	only the node itself, not its content
node.cloneNode(true)
	deep clone

node.remove()


-- add node to the DOM --
anElement.append(node, node2) 
prepend()
before()
after()
replaceWith()
	arg: node or string
	one or multiple args
	if string : will create a text node not an html one (escape)
	can also be used to move an existing node

anElement.insertAdjacentHTML(where, htmlString)
	turns the string into html elements (like innerHTML)
insertAdjacentText(where, text)
	creates a text node
insertAdjacentElement(where, element)
	must be an element
where
	"beforestart"	before the element
	"afterstart"	beginning of the element
	"beforeend"		end of the element
	"afterend"		after the element


parentElem.appendchild(node)
parentElem.insertBefore(node, nextSibling)
parentElem.replaceChild(newNode, oldNode)
parentElem.removeChild(node)
	old
	returns the appended node

document.write
	old
	only works when the page is loading (inline scripts)
	if called after : erases all content



new DocumentFragment()
designed to contain nodes (can contain multiple roots)
can use prepend, append on it
can pass to prepend, append,... => will add the content
alternative to an array of elements : x.append(...arrayOfNodes)



--- class ---
element.className
	full class attribute as a string
	read/write
	(className not just class because class was reserved in js)

element.classList
	iterable, indexable list of classes
x.classList.add(className)
x.classList.remove(className)
x.classList.toggle(className)
x.classList.contains(className)
	modify classes
	! div.classList.add(null/undefined) => adds a class "null"/"undefined"!
	! no empty string to add


--- style ---
elem.style
	corresponds to the style attribute
	! only the style attribute
	doesn't know what is set through css
	doesn't know what is computed
	<xxx style="display:none">
	attribute name modified intro property:
		background-color => backgroundColor
		(like custom data attribute)
eg. elem.style.display = "none";

elem.style.someAttribute = "";
	remove and style as if we never set a value

elem.style.cssText
	full style attribute as a string	
	read/write


-- computed style --
getComputedStyle(element)
getComputedStyle(element, pseudo-element)
	return an object similar to element.style
	read-only
	contains all the computed properties
	the actual resolved values (xxx% => xxxpx)



--- size ---
values 0/null if 
-not displayed (display:none, hidden=true)
-not attached to the DOM

prefer the properties below rather than getComputedStyle
getComputedStyle:
- affected by box-sizing
- may be a value such as "auto" and not a size in px

offsetParent
	closest positioned parent (or body)
	cf position: absolute
offsetLeft offsetTop
	offset to offsetParent

offsetWidth offsetHeight
	content+padding+border (not the margin)
	includes scrollbar if any
	outer width

clientLeft clientTop
	size of border left/top
	also includes scrollbar (adds to the size of the border)

clientWidth clientHeight
	content+padding (not the border, scrollbar, margin)

scrollWidth scrollHeight
	useful in case of scrolling
	not the size of the part visible but
	the entire size of the element, including the one not visible due to scroll

scrollTop scrollLeft
	how much has been scrolled


document.documentElement.clientHeight
document.documentElement.clientWidth
	size of the window
	without the scrollbar
		window.innerWidth window.innerHeight to get value with the scrollbar


window.pageXOffset
window.pageYOffset
window.scrollX
window.scrollY
	current scroll position
	read-only

window.scrollTo(x,y)
	scroll to a position

window.scrollBy(x,y)
	scroll relative to current scroll position

elem.scrollIntoView()
elem.scrollIntoView(true)
	scroll element into view (top of the page)
elem.scrollIntoView(false)
	scroll element into view (bottom of the page)

document.body.style.overflow = "hidden"
document.body.style.overflow = ""
remove scrollbar/scrolling
restore it



-- coordinates --
two systems:
-relative to the viewport (window)
 aka client
 changes when scrolling
-relative to the document
 aka page
 not affected by scrolling

same when no scrolling.
when scrolling : 
	window => changes (as content scroll through the window)
	document => doesn't change


elem.getBoundingClientRect()
	returns an object with:
		x y
		width height
		top bottom
		left right
	relative to the client : window
	can be negative : scrolled past the element
	can convert to page related coordinates by using window.pageYOffset !

document.elementFromPoint(x, y);
	most nested element at (x, y)
	relative to client
	(x, y)must be within the viewport



--- Events ---
<div onclick="js here">
<div onclick="aJSFunction()"> //parens
anElement.onclick = aFunction //no parens
	only one listener can be attached
	this is the element

anElement.setAttribute('onclick', function (){}); 
	doesn't work
	value of setAttribute is a string

elem.addEventListener(
    "click", 						//event
    callbackOrHandlerObject, 				//handler
    {								//options
        once: false,
        capture: false,	// handler runs during the capture phase instead of the bubbling phase
        passive: true, // cannot/will not prevent default
    });
elem.removeEventListener("click", fn)
   	can add multiple listeners

some events only work with addEventListener
eg.: DOMContentLoaded

handlers run in the order they where added

callback function:
	called a handler
	this = the element (requires a function, doesn't work with arrow function)
	first argument = Event object
	always has an automatically created event variable containing the event
		(as if the callback was wrapped in a function with an event argument)

handler object
	object with an handleEvent method that works like a callback function

anEvent.type
	type of event ('click',...)
anEvent.currentTarget
	element currently handling the event
anEvent.target
	element initially stated to handle the event
anEvent.clientX
anEvent.clientY
	coordinates of the cursor
	if applicable


-- events --
click		
mousedown	
submit		form
keydown
contextmeny	right-click
touchstart
touchmove

