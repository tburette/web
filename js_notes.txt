js warts
negative index : like 0 or count from the end of the array/string?
	inconsistant (indexOf and substring vs slice and substr)

objects used as dictionary (no length, perfs, limited keys)

map accepts key but different instances of the same object compare false

o == 1 => not the number primitive conversion but the string one

let proto = {
    stomach: [],
    eat(food) {
      this.stomach.push(food); // changes proto.stomach)
      this.stomach = [food]; // set stomach on the instance object)
    },
}
instance = Object.create(proto); // or through a constructor

var anywhere (at the end, if(false),..) in a function makes the variable local

Array() same as new Array()
Date() different from new Date() (str vs object)

behaviour of str.match (type of value returned) depends on a flag of the regExp (g global)

return in an executoreadystatechanger (new Promise(xxx)) does nothing (does not turn the promise into a fulfilled promise)
yet return in handler does
yet throw in handler does settle the promise into a rejected one


behaviour of code changes depending on whether the code is in a module or not
see "Changes to module compared to standard script:"


(node) use strict or not depending on an external package.json file. Can't tell behaviour just by looking at the source code itself.


addEventListener: (case)
readystatechange
but
DOMContentloaded

readystatechange doesn't bubble
but
DOMContentLoaded bubbles

DOMContentLoaded on document but load on window

addEventListener('DOMContentLoaded' ...)
but not
ondomcontentloaded

onfocus
but not
onfocusin (must use addEventListener)

date
	autocorrection instead of error
	fullyear
	month starts at 0

generator function
doing a return
	value not available in for..of loop
	value available in generator object : {done:true, value=<return value>}


todo

Strict-Transport-Security

http cache

web worker

<dialog>

https://github.com/goldbergyoni/javascript-testing-best-practices/blob/master/readme-fr.md


== rules
weird comparison rules
	https://javascript.info/comparison

srcset (image resolution switching)


standard
last published:
https://www.ecma-international.org/publications/standards/Ecma-262.htm
includes proposals:
https://tc39.es/ecma262/
https://github.com/tc39/proposals
unit test: mocha, jest

courses:
https://javascript.info/
https://developer.mozilla.org/en-US/docs/Web/JavaScript
https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/#basic-javascript
codeacademy
https://www.theodinproject.com/paths/foundations/courses/foundations
udemy
	ES2015	https://www.udemy.com/course/the-advanced-web-developer-bootcamp/
	ES6		https://www.udemy.com/course/modern-javascript-es6-for-react-js/
nodeschool


js questions
https://github.com/ganqqwerty/123-Essential-JavaScript-Interview-Questions
https://github.com/sudheerj/javascript-interview-questions



npm
npm install
-g
	install globally
-D
	devDependency (develop/stest)

npm init
	create project
-y --yes
	defaults, do not prompt questions

babel
	transpiler : convert modern js into js that can be run on older js engines
	to be combined with a polyfill

"use strict";
Introduced in ES5 (2009), backward incompatible changes
at beginning of script
at beginning of function
automatically enabled by modules and classes?
! node : if package.json has "type": "module" code executed strictly even if no "use strict", class,... !

;
always ; recommended


==
	does type conversion
	if number + a string/boolean => the string/boolean converted to number
===
	no type conversion
	different type => different

Object.is(a, b)
	like === but
	NaN is NaN
	+0 is not -0
	

primitive types (singlue value, stored as value in variables)
string
number
bigint
boolean
symbol
null
undefined

Object type
	{}
	function
	array
	Map
	...

String, Number, Boolean, Symbol
	allow calling methods on primitive types
	eg aString.toUpperCase(), aNumber.toFixed(2)
	as if the js Engine created a temporary object wrapper around the primitive to allow an operation to carry out.

new Number(0)
new Boolean(false)
	create a wrapper object
	NEVER USE !!!
	awful:
		typeof is object
		considered truthy (like all objects)!!
			if(new Boolean(false)) console.log("this will print!")
			if(new Number(0)) console.log("this will print!")
	Number("123") ok : returns primitive

typeof
	return string of the type

true/false	'boolean'
null		'object'	!
[]			'object'	!
{}			'object'
function() {}	'function'
() => none	'function'
class Foo{}	'function'
1			'number'
1n			'bigint'
Symbol("a")	'symbol


null
	no value, unknown, empty
	x = null; makes sense
	Number(null) === 0

undefined
	value not assigned
	x = undefined; to avoid
	Number(undefined) === NaN

null == undefined
	this is a special rule
	(eg. [] != {})



--- Number ---
numbers are double
0.1 + 0.2 == 0.30000000000000004
Number.MIN_SAFE_INTEGER
Number.MAX_SAFE_INTEGER
	around 10**15, 2^53-1
	Number.MAX_SAFE_INTEGER +1 === Number.MAX_SAFE_INTEGER + 2

1_000_000_000
1e3 === 1000
1e2 === 100
1e1 === 10
1e0 === 1
1e-1=== 0.1

0xff
	hexa

0b01111111
	binary


0o10
	octal

010	
use strict : 	 error
non use strict : === 8, but Number("010") === 10

Number(<something>)
+a_string
	convert to number (eg. a string)

new Number(12) !== 12 
typeof 12 => number
typeof new Number(12) => object
!!0 => false
!!new Number(O) => true

but Number(0) is the same as 0

parseInt(str)
parseInt(str, radix) // default 10
parseFloat(str)
	convert to number
	ignore non-number text at the end of the string
	Number("123x") === NaN
	parseInt("123x") === 123

Infinity
	obtained with the keyword or dividing by zero (except 0/0, Infinity/Infinity,..)
	
Nan
	cannot parse a number ParseInt(), Number()
	string + operation "foo" / 2


aNumber.toString()
aNumber.toString(2) // base

2.toString() // error
(2).toString() 2..toString() // ok


BigInt
	represents integer of any size
	! fairly recent (Safari 2020)
	BigInt(1)
	BigInt("1")
	1n 				// BigInt literal
	BigInt(1) + 1	// NO
	BigInt(1) == 1	// yes (also <, <=,...)
	BigInt(1) === 1 // false
	
	can use * + / < > ...
	/ rounds toward zero
	cannot use with Math.xxx, +aBigInt
	


bitwise operators
AND ( & )
OR ( | )
XOR ( ^ )
NOT ( ~ )
LEFT SHIFT ( << )
RIGHT SHIFT ( >> )
ZERO-FILL RIGHT SHIFT ( >>> )
numbers are converted to signed 32 bits integers. Truncated if needed


logical operators
|| && ! ??
	if operand is not a boolean
		convert to boolean to evaluate if true/false
		if operand is returned (see below): returns the original value (not converted)
|| || || ...
	return first true value
	or last value
&& && && ...
	return first false value
	or first value

a ?? b
	nullish coalescing operator
	nullish = null or undefined ( https://developer.mozilla.org/en-US/docs/Glossary/Nullish )
	if a not null or undefined: returns a
	if a null or undefined: 	returns b
	fairly new (2020)
	useful to give a default value if something may not be defined
		alert(user ?? "Anonymous");

a?.b
	optional chaining
	the object on the left may not exist
	if a is nullish (null/undefined) return undefined
	if a exists returns value of b (which can be undefined)
	permits: a?.b?.c
	a && a.b && a.b.c is similar but
		more verbose
		if falsish value : return falsish value instead of undefined
	the variable a must exist (but may be null/undefined) otherwhise exception
object.function?.()
	calls the function if it exists
	returns undefined if it does not exist
object?.[key]
array?.[i]
	read if object/array exists, otherwise returns undefined
delete obj?.value
	delete obj.value if obj exists
a_null_variable?.name = "John";
	SyntaxError (cannot do what amounts to undefined = "x");



--- String ---

"13"[0] === "1"
"13".charAt(0) === "1"		// was the only way originally
"hell".length === 4

"ba" < "bar"
	lexicographical order
	uppercase before lowercase  (cf ASCII table)
	diacritical marks after non diacritical marks (z < รถ) (cf unicode)
	str.localeCompare to be language aware

`template literal ${expression}`
	${} = literal
`multi
	line`
	multiline (return and newline part of the string)

a_function`tagged template literal`
	call a_function passing the strings and ${} to it
foo`tagged ${"hi"}template literal ${1+1} hi`
same as : foo([ 'tagged ', 'template literal ', ' hi' ], 'hi', 2)

String(something)
	convert to string

str.localeCompare(otherString)
	compare with locale awareness. Eg. ร < P

str.toUpperCase()

str.indexOf(searchedString, fromIndex)
	returns index
	-1 if not found
	! careful:  if(str.indexOf(...)) <== wrong (fails on -1, 0) use includes instead
	negative index like 0

str.includes(searchedString, fromIndex)
	returns true/false


"oh hello".substring(3, 7)
	returns substring
	from, to (excluded)
	can ommit to
	negative index like 0
	if from > to => swaps index

str.slice(startI, endI)
	modern version of substring.
	similar:
	returns substring
	endI excluded
	can ommit endI
	different:
	negative index counts from end of string (-1 = last index)
	if start > end => empty

str.substr(startI, length)
	negative index counts from end of string (-1 = last index)

str.split(', ')
	turn string into array based on the delimiter



--- Symbol ---
Unique identifier
NOT like string
NOT like smalltalk's #symbol


Symbol("a") != Symbol("a")
	each symbol is unique
	even if same description
	(exception see global registry Symbol.for)

alert(Symbol("hi"))
"My symbol is " + Symbol("hi")
	TypeError, symbols do not auto convert to string

Usage 1:
if use a symbol as a key (obj[symbol]) on object,
since no one else can generate the same symbol
we can have "hidden" private properties (cf Van Roy)
o[s] = "pseudo private value"
	s won't show up in
		for loop
		Object.keys()
	but will show up in the String(o)
not quite true in reality, can get the "private" symbols used as keys of an obj:
	Object.getOwnPropertySymbols(o) returns the symbols of an object
	Reflect.ownKeys(o); returns all the keys (including symbols) of an object

Object.assign WILL copy the symbolic properties

String(Symbol("x"))
Symbol("x").toString()
	convert to string 'Symbol("id")' manually

Symbol("desc").description == "desc"
	gets the (string) description

Symbol.for('x')
	global registry of symbol
	Symbols in the registry are called global symbols
	create new or return existing symbol
	Symbol.for("x") == Symbol.for("x")
	Symbol("x") != Symbol.for("x")
	similar to smalltalk's #symbol

Symbol.keyFor(some_symbol)
	returns the description of a global symbol
	pointless : can use some_symbol.description
	can be used to determine if a symbol is global or not

Usage 2:
There are "system symbols" used by javascript implementation, defined in the js specs and used by some algorithms of the language:
Symbol.hasInstance, Symbol.iterator, Symbol.toPrimitive,...
Can alter the built-in behaviour:
- make an object iterable (we choose the returned elements)
- ...



--- variables ---


var x = 0;
var x = 0, y = 1;
	set variable
	function (or global) scope (visible in the rest of the function)
var x;
	var has the value undefined
	different from x not being defined

function foo(){
    x = 1 //local, despite the later var x 
    var x;// same with if(false){var x;}
}
foo();
console.log(x) // x is not defined
	a declaration of a variable _anywhere_ with var is enough to make it  a local/function scoped variable

x = 0;
	global var
	error in strict mode

let a = 12;
	block scope
	if executed in global scope, does NOT set a property on global object (window)

let a = 12;
let a = 11;
	error, can't declare a variable twice

for(let i = 0; i < 3 ; i++) {
    arr.push(function foo(){
        console.log(i); //i different with let. Would be the same xith var
    });
}

const a = 12;
a = 11; // error
	block scope
	cannot reassign
	must assign a value;

function foo(){}
	hoisted
	in strict mode : function definition is block scoped : exists only within the block
	in non-strict mode : function scoped

variable name
	first character:  letter, $, _
	other characters: number, letter, $, _
	case sensitive
	there are reserved names (strict mode)
	camel case
	uppercase + _ for constant


,
	lower precedence than =
	evaluate expr to the left of , 
	evaluate expr to the right of , 
	return result of right/last one
	commonly used when assigning value (variables creation, for loop)



-- Array ---
['hi', 1, true]
new Array('hi', 1, true);
	rarely used (more verbose than array literal)
	if single argument of type number : create an array of that size!
array is an object with extra stuff (length, managing the ordered collection)
can be sparse
	a = [];
	a[10] = null;
	a.length === 11
	or
	Array(11)
	! some operations do not work on sparse array
		let a = Array(3)
		Array(3).map((_, i) => i);			// does nothing, no iteration
		Array(3).fill().map((_, i) => i);	// works
fill(value)
	fill array with value
fill(value, start, end)
	determine the part of the array to fill
	doesn't add elements if start/end outside the size of the array
	accepts negative value

== on two arrays is always false unless it is the same array (like all objects)
delete array[i]
	sets element to undefined
Array.isArray
	typeof [] is 'object'
	this allows to tell if something is an array
push(elem);
push(elem, elem2);
	add to the right
unshift(first)
unshift(first, second)
	add to the left
pop()
	remove last
shift()
	remove first
.length
	last index + 1
	writable!
[1, "hi"].join(", ");
	"1, hi"
	see also str.split
slice(from_i, [to_i])
	returns new subarray with elements
	does not modify the array
splice(start, deleteCount, item1, item2, itemN)
	-remove items
	-remove and add items
	-add items (deleteCount = 0)
	in place
	returns removed elements
arr.concat(arg1, arg2)
	does not change arr
	returns new array with arr concatenated to arg1, arg2,..
	args can be array or single elements
	if arg is an object with a [Symbol.isConcatSpreadable] property then all the property values of that object will be added to the result (instead of the object itself)
indexOf(item, from)
lastIndexOf(item, from)
includes(item, from)
	search for element. Uses ===
some
every
flat
flatMap
find(fn)
	returns undefined or the first match
	fn = function(item, index, array){}
findIndex(fn)
	like find but returns the index
filter(fn)
	returns array of all matching
map(fn)

reduce(fnWithAcc, optionalInitialValue)
sort(compareFn)
	sorts in place
	!! if no compareFn => sorted as string
		[1, 2, 15].sort() => [1, 15, 2]!
	compareFn(a, b) returns positive/zero/negative number
reverse()
	in place
	
a_function(...array)
	= a_function(array[0], array[1], array[2]);
	spread operator

for(let value of array){}
	iterate
forEach(function(item, index, array){})

let arr = 'hello over there'.split(' ')
let  [a, , b] = arr
	array destructuring
	any iterable on the right side



-- Iterable ---
Symbol.iterator property is a function returning an object with next()
can be used in for..of

objectThatMustBeIterable[Symbol.iterator] = function() {
    return {
        next() {
            return {done: false, value: this.current++};
            return {done: true};
        }
    };
};

can simplify with a generator function : 
objectThatMustBeIterable[Symbol.iterator] = function*() {
    yield 1;
    yield 2;
}
or just
let o = {
    *[Symbol.iterator](){
        yield 1;
        yield 2;
    }
};


Can make a self-iterable
range[Symbol.iterator] = function() {
    return this;
}
range.next = function() {
    return {done: false, value: xxx};
    return {done: true};
};
	downside : only one iteration possible

Manually interacting :
    iterator = iterable[Symbol.iterator]();
    while(true){
        let result = iterator.next();
        if(result.done) break;
        console.log(result.value)
    }



-- Asynchronous iterable ---
get elements one by one asynchronously
= iterable + promise
like normal iterable but:
- [Symbol.asyncIterator] 			instead of [Symbol.iterator]
- next() must return a promise 		instead of any value
  (next can be await to simplify)
- for await..of 					instead of for..of

let range = {
    from: 1,
    to: 5,

    [Symbol.asyncIterator]() {
        return {
            current: this.from,
            to: this.to,

            next() {
                return new Promise(resolve=>{
                    if(this.current >= this.to){
                        resolve({done: true});
                        return;//?
                    }
                    setTimeout(()=>{
                        resolve({done: false, value: this.current++})
                    }, 500);
                });
            }
        };
    }
}
	can simplify with async generator

can use async generator to make async iterable
= iterable + promise + generator

let range = {
  from: 1,
  to: 5,

  // this line is same as [Symbol.asyncIterator]: async function*() {
  // async to return Promise
  // * to handle the iteration
  async *[Symbol.asyncIterator]() {
    for(let value = this.from; value <= this.to; value++) {

      // make a pause between values, wait for something
      await new Promise(resolve => setTimeout(resolve, 1000));

      yield value;
    }
  }
};
for await (let value of range)console.log(value);



Array like object
	an object with keys: 0, 1, 2,... and length

Array.from(arrayLike)
Array.from(iterable)
	returns an object which behaves like an array:
		all the methods (push,...)
		for..of
		indexed access
	works on non array-like/iterable : as if the object was an empty array
[...anIterable]
	creates array from iterable

[a, b, ...rest] = anIterable
	destructuring
[a="default", b="default", ...rest] = anIterable
	can provide default value

similar exists for objects : {...obj}


--- Map ---
{key:0, "k":0}
	creates an object
	looks like a dictionary but isn't : 
		is an object
		default keys
		keys are string (or symbol) only
		no size attribute
use new Map() for a real dictionary type
	allows keys of any type

can have object as key

key does not have to be readonly
no equality/hash operator overloading
comparisoin based on identity

m = new Map();
m = new Map([ ['k', 'v'], ['k2', 'v2']])
m = new Map(Object.entries(obj))
set(key, value)
	can chain
get(key)
has(key)
delete(key)
clear()
size

Object.fromEntries(map)
	makes a plain object from a map object
	map = iterable/array like
	can use Object.entries(o) as source

for(let v of m)
	iterate on entries [key, value]
for(let v of m.keys())
for(let v of m.values())
forEach( (value, key, map) => ...)

WeakMap
	like map but
		key must be an object
		removed automatically if object has no other reference
		typical use : 
		-add info to an object belonging to other code. Do not want to modify the object itself but still want associated data
		- cache the result of a computation (for a given object)
	no size
	no iteration

-- set --
new Set()
new Set(iterable)
add(value)
delete(value)
has(value)	// NOT in
clear()
size

for(let v of m)
for(let v of m.keys()) //useless
for(let v of m.values()) // for compat with map, same as keys
for(let v of m.entries()) // for compat with map : [value, value]
forEach((value, valueAgain, set) => ...)
	works on Map, Set, Array
	note : also exists Object.keys, Object.values, Object.entries for objects (different from functions here)

WeakSet
	only contains objects
	no size
	no iteration
	does contain has, delete
	can determine if an element is or is not in the set
	eg.: message has been read if is in the set.



if(x){
    console.log("yup");
}else if(true) {
    console.log("nope");
}else{
    console.log("nope")
}

if(variable = xxx) yyy;
	assign xxx to variable

if("hi") true
	converts content of () into a boolean value
	
true ? 1 : 2;
	ternary operator

v = 'a';
switch(v){
    case 'a':
        console.log("this is a");
        break;
    case 'A':
        console.log("this is A");
        break;
    default:
        console.log("other");
        break;
}


while(x > 0) {...}
do { ... } while(x > 0)

outer: for(let i = 0; i < 10; i++) {
    for(let j = 0; j < 3 ; j++) {
        console.log(i, j);
        break outer;
    }
}
	can break of outer loop by giving a label

xxx: {
	break xxx;
}
	also work without a loop

for(let x = 0; x < 2; x++){};
for(let x in obj){};
	enumerable property names of objects (enumerable: true in descriptor)
	included enumerable inherited properties
	order of iteration
		if key is string : order of property creation
		if key is string representing non negative integers:
			sorted integers first
			then other strings
			0, 1, 2, ... => integer properties
			-1, +2, ...  => NOT integer properties (sorted as string)
		(I imagine it is useful if iterate over an array, obsolete : nowadays would use for...of)
	iterate on
		object	(x are the Enumerable keys)
		array	(prefer the use of for..of)
		Map		(prefer the use of for..of)
		NOT string (works but keys: 0, 1, 2,... prefer the use of for..of)
	it's a weird choice to enumerator object (outside debugging?)
	hasOwnProperty()
		exclude properties of prototypes
		builtin properties (of Object) already ignored
for(let x of iterable){};
	iterate on iterable objects
	iterable[Symbol.iterator] magic behind the scene
	iterate on
		array
		string
		Map
		Set
		NodeList (document.querySelectorAll)
		Object.entries/keys/values(an_object) to iterate over objects
forEach
a.forEach(elem => console.log(elem));
a.forEach((elem, index) => console.log(elem, index));
a.forEach((elem, index, array) => console.log(elem, index, array));
	for arrays



-- Date --
Date and time
important:
	use FullYear NOT year
	month : 0-based (0 = january)
	day: use getDate NOT getDay
	getDay : day in the week, 0-based (0=sunday)
	timestamp are in ms, not s as is more common
	autocorrection when date is out of range
	by default values are set/returned relative to current timestamp
	can set/get values relative to utc with UTC variant of methods

new Date()
	current date/time
Date()
	current date as a string!
new Date(existingDate)
new Date(ms_since_1_1_1970)
	date.getTime() to get the timestamp
	date can be before 1970 => negative timestamp value
new Date("2017-01-26")
new Date("2017-01-26 01:02:59")
new Date("YYYY-MM-DDTHH:mm:ss.sssZ")
	or Date.parse(str)
	Z is the time zone
		Z = UTC+0
		+-hh:mm
		(time will be set relative to that timezone, the created date will be displayed relative to the local timezone)
new Date(year, month, date, hours, minutes, seconds, ms)
	month: 0 = jan
uses local time zone

getTime
	returns the timestamp
Date.now()
	returns current timestamp
	shortcut for new Date().getTime()

getFullYear
getMonth // 0-11, 0 = january !
getDate // day in the current month !
getHours getMinutes getSeconds getMilliseconds
getDay
	day of the week 0=sunday, 6=saturday
getYear
	do NOT use
	weird value

variations of above methods:
setxxx
	set the value
	Date objects are mutable
setUTCxxx
	sets the value relative to UTC. Date object remains in local time
	setUTCHour(22) and local timezone at T+1? => getHours() will be 23
getUTCxxx
	(add UTC)
	value relative to UTC instead of local time
getTimezoneOffset
	difference in minutes between local timezone (timezone used in the date object) and UTC

autocorrection
if create a date/set a value too big/too small
	will auto adjust
	new Date(2000, 0, 32) => date will be in february
useful :
	set the date to x seconds after the date : date.setSeconds(date.getSeconds()+x);
	set the date to the last day of the previous month : setDate(0)
double edged : can give wrong value and there won't be an error

conversion to primitive (number timestamp)
+aDate
	converts date to timestamp (see primitive conversion)
aDate - anotherDate
	difference in timestamp => difference in ms



--- function ---

a function with no return value or no return
	returns undefined

function foo(){}
	function declaration
	function statement
	parse time

const foo = function(){}
	function expression
	runtime

const foo = function bar(){}
	named function expression

const func = new Function('arg1', 'return arg1 + 1;')
	new Function syntax to create a function from string
	not to be confused with object creation through constructor call
	no access to variables available in the environment where new Function is called

(function() {
    //...
})();
	IIFE
	Immediately Invoked Function Expression
	not too useful anymore can be replaced in most situation with a block {}
	case where still useful : 
	- want to assign the result of a calculation to a const
	  const foo = (function(){...return x;})();

void function(){console.log("hello")}()
true & function...
! function...
...
	unusual ways to write an IIFE
	technically don't need to use ()
	can use anything that turns the function declaration into an expression


Arrow function
() => { return 2 }
() => 2
x => { return x; }
x => x
(x,y) => { return x+y; }
(x,y) => x+y
	lambda

arrow function don't have their own this
this comes from the context!
Useful and intuitive when create an arrow function within a function



a();
function a() {console.log("a");}
	function declaration
	call before definition ok (hoisting)

b();
b = function() {console.log("b");};
	function expression
	ko : b doesn't exist at the moment of the call

c();
c = () => console.log("c!");
c = one_param => console.log("c!");	// no ()
c = (p1, p2) => console.log("c!");
c = (p1, p2) => {console.log("c!"); ... };
	ko : c doesn't exist at the moment of the call


default parameter
function foo(param=[]){
    param.push("hi");
    console.log(param);
}
foo(); // no arg
foo(undefined); 
	default parameter used if no arg passed OR undefined passed!
	(but default NOT used if null)
	default parameter evaluated each call
		opposite of python where it is evaluated once
		risk of modifying a default arg and affecting subsequent calls does not exist



a_function(...array)
	rest parameters
	= a_function(array[0], array[1], array[2]);
[1, 2, ...array]
	spread operator


function foo(...array)
	rest parameters
	array is a regular array

Math.max(...array)
	largest value in an array
	string converted to number
	other value : returns NaN

arguments
	within a function : the arguments passed
	arrow functions don't have their own arguments (it is the one of the parent function)
	array-like, iterable but does not an array : does not support array function
theFunction(...args){}
	alternative to arguments
	real array


a function is an object. It can have properties
name
	name of the object
foo = function() {} //foo.name === "foo"
obj.prop = function() {} //obj.prop.name === "prop"
	contextual name
	if no name : uses name of variable it is assigned to!
array.push(function(){}); //array.pop().name === "" got em!

length
	number of parameters



--- generator ---
function* gen() {
	yield 1;
	yield 2;
}
function *gen() {} // also works but not used

returns a generator object which has a next() method that returns { value:x, done:y} objects
lazily executed : function doesn't start until next() of generator object is called

values returned by successive next(): 
eg.: yield 1; yield2;
{ value: 1, done: false }
{ value: 2, done: false }
{ value: undefined, done: true }

eg.: yield 1; return 2;
{ value: 1, done: false }
{ value: 2, done: true } // won't appear in a for..of
{ value: undefined, done: true }
	return value does not show up in for..of!

cannot call yield from a function or arrow function

throwing an exception in the generator throws the exception in the caller

function* generateSequences() {
    yield* generator(0, 10);
    yield* [10, 11, 12];
}
	generator composition
	works with generator and iterable

function* gen() {
    let valueFromSecondNext = yield "first yield value";
    console.log(valueFromSecondNext); // "value passed to first yield"
}
let g = gen();
// do not pass value to first next
console.log(g.next()); // { value: "first yield value", done: false }
console.log(g.next("value passed to first yield"));  

g.throw(new Error("msg"));
	can pass exceptions
	if exception isn't caught in the generator it is thrown (back) in the caller

g.return(value);
	stops the generator (done is true from now on)
	value will be the value of the object returned by next()

can emulate generator with a function returning a function:
function pseudoGen() {
  let value = 0;
  return function() {
    return value++;
  }
}
let g = pseudoGen();
g();
but will not have the nice features: for..of, yield*, g.return,...


--- async generator ---
1)
//async simplifies use of Promise
async function async(){
    return 1;
}
async().then(resolve => {
    console.log(resolve);
})
console.log(await async());


2)
//generator function simplifies iteration (Symbol.iterator)
function* gen() {
    yield 1
    yield 2
}
for(let v of gen())console.log(v);


1+2 = 
//async generator = async + generator
async function* asyncGen() {
    yield 1;
    await new Promise(resolve => setTimeout(resolve, 1000))
    yield 2;
}
for await(let v of asyncGen())console.log(v);
result = await genOjbect.next()



-- Callback --
//simple callback
aFunction(..., function(value){
});

//callback with error
aFunction(..., function(error, value){
	//no error : error null, value
	//error:	 error, no value
});

to avoid callback hell:
- put into separate (top-level) functions instead of imbricating
  inconvenient : have to jump around the various functions to follow execution
- promise



--- event loop ---
1) run oldest macrotask (or wait for one)
2) run all available microtasks of the macrotask
   after: control returned to the browser's event loop
3) render
4) repeat

-- macrotask --
aka task
endless loop running (macro)tasks, 
macrotasks : <script> loading, event handler, timeout callback,...

macrotask queue (V8 term) : FIFO task queue
if no task to run currently : wait for task
node : if no task ready to run or pending -> exit.

no rendering when a task run (no matter how long it runs) ! 
	eg.: in script change the DOM then do long computation => won't see change until end of computation
long running task : raises alert to the user


-- microtask --
microtask : handlers in then, catch, finally and await.
when a macrotask ends : all queued microtasks are run.

within an execution of a macrotask : all the microtask are run in an environment that is not affected by other macrotasks.
There has been no change caused by external events (user action, mous coordinates change, some event handler changing the DOM,...)

queueMicrotask(func)
	adds func to the microtask queue
	will run before control is returned to the event loop
	schedule code to run later but before other (macro)tasks that can change the world underneath our feets
	
setTimeout => 		schedule macrotask, other code may run
queueMicrotask =>	schedule microtask, we are at the end of our own code



-- Promise --
new Promise(executorFunction);
let aPromise = new Promise(function(resolve, reject){ // executor function
	... // usually some asynchronous work
	// single argument
    resolve(1);
    return x; // NO! does not settle the promise
    
    // recommend returning an Error object (like throw)
    // alternative : throw
    reject(new Error("error x")); 
})
the executor function is run immediately (before returning the promise object)

only the first resolve/reject has an impact on the listeners

if return in the executor : handlers will never run, promise will never settle

promise has a (internal, hidden) state : pending or settled(fulfilled/rejected)

when there is a reject : the closest reject block catches it (catch or then(null,xxx).

a throw xxx in executor or a handler turns the result into a reject

Can create custom "thenable" object : an object with a then function
	can be returned by a handler
	will be treated like a native promise.
	allows objects that can be used with the promise system without having them inherit from Promise
let thenable = {
    then(resolve, reject) {
        resolve(2);
    }
}
	typically they would be a full type created with a class or constructor

handling promise result
then()/catch()/finally()
	blocking
	can call multiple time on the same object(multiple subscribers)
	can chain
	they return a new Promise object each time

.then()
	if there is a chain: must return a value otherwise next handler will see undefined!!!
	can return a new Promise object or a value (will turn into a promise)
	can split a complex then handler in two simpler then => return intermediate value from the first then handler (even if no async operation)
.catch()

.finally()
	returns a promise with the same settles/rejected value (unless exception)
	within the handler:
		return has no effect
		throw exception : finally returns a rejection promise with that exception

	
aPromise.then(function(result){
    // onfulfilled
    console.log("fulfilled: " + result)
},
function(error){
    // onrejected
    console.log("rejected: " + error)
});


aPromise.catch(function(error){
    console.log(error);
})
same as:
aPromise.then(null, f);

aPromise.finally(function(){
	// no arg
	// for cleanup
})


if a rejection promise is unhandled it is printed in the console.
Can catch them:
window.addEventListener('unhandledrejection', function(event) {
  // the event object has two special properties:
  alert(event.promise); // [object Promise] - the promise that generated the error
  alert(event.reason); // Error: Whoops! - the unhandled error object
});

process.on("unhandledRejection", function(reason, promise){
    console.log("!!!", reason, promise);
})


Promise.all
	arg = array/iterable of promises
		there can be regular values in the iterable as well
	then : arg is an array (same size/order as the arg)
	if rejection : first rejection is passed (others are ignored)

Promise.allSettled
	arg = array/iterable of promises
	then : arg is an array of :
		{ status: 'fulfilled', value: 1 },
		{ status: 'rejected', reason: [Error: err msg] }
	waits for all the promises to be settled

Promise.race
	arg = array/iterable of promises
	returns the first settled promise

Promise.any
	arg = array/iterable of promises
	returns the first fulfilled promise
	if all are rejected : returns an AggregateError containing an errors array

Promise.resolve(value)
	creates a resolved promise from the passed value

Promise.reject(error)
	creates a rejected promise from the passed value


promisification : turn a function accepting a callback into a function returning a promise

fetchFromAPI : callback has two parameters: error, value
function fetchFromAPIPromise(name) {
    return new Promise((resolve, reject) => {
        fetchFromAPI(name, (error, result) => {
            if(error) reject(error);
            else resolve(result);
        });
    });
}

fetchFromAPI : callback has single parameter: value (no error)
function fetchFromAPIPromise(name) {
    return new Promise((resolve, reject) => {
        fetchFromAPI(name, resolve);
    });
}




--- async await ---
async
async function f() {
    return 1;
}
	the function always return a Promise
	return value wrapped in a resolved promise
	or thrown exception wrapped in a rejection promise
like:
function f() {
	return Promise.resolve(1);
}

async function f() {
  throw new Error("msg");
}
like:
async function f() {
  return await Promise.reject(new Error("msg"));
}

await
let result = await f();
let result = await aPromise;
blocks until the promise is settled then returns the value
only works inside async functions 
works globally (not always?)
works on thenable objects

await 1
	creates a resolved promise

handle rejection:
try{
    let v = await p2;
}catch(err){
    console.log(err);
}


--- OO ---

{}
	object initializer
	aka object literal
	keys converted to string

new Object()
	arg object => returns that object (==)
	arg null/undefined => returns a new empty object
	other value (string, int,..) => wrap that value in an object

a.key
a["key"]
	get value of key

{
  [a_var]:1; //any expression really
}
	computed property
	Take the value, use its string representation as the key

name = "John";
{
  name // equivalent to name: name
}
	property value shorthand
	result : Object { name: "John" }

obj = {
  shorthandMethod(){ // equivalent to shorthandMethod: function() {
    ...
  }
}
	method definition shorthand
	! contrary to the long form cannot be used as a constructor ??? why
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#method_definitions


obj.key = x;
obj["key"] = x;

"property_name" in obj
	test if the property exists
	almost like obj.property_name !== undefined but returns true if we stored undefined in property_name

delete object.property
delete object["property"]
	removes key from object

delete someVariable
	does nothing (non strict mode)
	error (strict mode)

delete someObj.propertyAtThePrototypeLevel
	does nothing (no error)

object converted to boolean : always true

Object.keys()
Object.values()
Object.entries()
	return arrays (contrary to map.xxx, set.xxx, Array.xxx which return an iterable)
	do not appear:
		symbols
		properties with flag enumerable: false
		(can get them both with Reflect.ownKeys())
		properties from prototype (as if filtered with hasOwnProperty()

for(let [key, value] of Object.entries(obj)){}



-- Properties --
property attributes : value + flags
property flags:
writable		read-only or not?	
enumerable		appear in loops
configurable	can be deleted, flags can be changed
a normal property : 3 flags true

for a getter/setter property:
get
set
enumerable
configurable

writable: false
	write non strict : nothing happens
	write strict: error

configurable: false
	prevents property from being deleted
	cannot change flags/value (EXCEPTION : can set writable to false)
	often combined with writable false otherwise can set writable back to true with Object.defineProperty


property descriptor : object describing a property (configurable, enumerable,...)
{value:x, writable: true, enumerable: true, configurable: true}
	descriptor for a data descriptor
{get: function(){}, set: function(v){}, enumerable: true, configurable: true}
	descriptor for a accessor property

Object.getOwnPropertyDescriptor(obj, propertyName)
	returns a property descriptor : value + flags

Object.getOwnPropertyDescriptors(obj)
	get proprety descriptors for all properties
	returns an object: {propertyName: {propertyDescriptor}, ...}
		same object structure as in defineProperties
	all including symbols and non-enumerable

Object.defineProperty(obj, propertyName, descriptor)
	sets attribute
	eg. Object.defineProperty(o, "a", {value: "hello", enumerable:false})
	if creates a new property: missing flags are assumed false




Object.defineProperties(obj, {
	prop1: {...},
	prop2: {...},
})
	same object structure as in getOwnPropertyDescriptors

Object.getOwnPropertySymbols(o)
	get all Symbol properties
Reflect.ownKeys(o)
	all the keys (including symbols and non-enumerable)

Object.isExtensible(obj)
Object.preventExtensions(obj);
	cannot add new properties
	
Object.isSealed(obj)
Object.seal(obj);
	cannot add/remove properties.
	Sets configurable: false on all properties
	
Object.isFrozen(obj)
Object.freeze(obj)
	cannot add/remove/change any property.
	Sets configurable: false, writable: false on all properties



data property : usual property
accessor property : property with a getter/setter method behind it.

let obj = {
  get propName() {
    // getter, the code executed on getting obj.propName
  },

  set propName(value) {
    // setter, the code executed on setting obj.propName = value
  }
};

Create an accessor property with an accessor descriptor:
Object.defineProperty(object, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  },
  //enumerable, configureble..
});

to have a "private" backing field for a property:
_privateProperty



-- Object destructuring --
o = {
    a: "aa", 
    b: "bb",
    1: "one value",
}
let {a, b, 1: one} = o;
a === "aa"
b === "bb"
one === "one value" //variable name different from the key
	destructuring objects
	extract values of properties and put them in variables
let {width: w = 100, height: h = 200, title} = options;
	with default value

can have multiple levels
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};
// destructuring assignment split in multiple lines for clarity
let {
  size: { // put size here
    width,
    height
  },
  items: [item1, item2], // assign items here
  title = "Menu" // not present in the object (default value is used)
} = options;

let options = {
    title: "title", 
    items: [1]
}
function manyArgs({title = "default", items = [],...} = {}){}
manyArgs(options)
	can use on parameters


the way the function is called determines if it is:
	- a function (this not attached to object but global/undefined)
	- a method (this = object)
	(except if used bind)
this is the opposite of python and many languages where this in a method is always bound to an object
a = {
    attr: 0,
    func: function() {
        return this;
    }
}
a.func(); // this = a
f = a.func
b = f() // this = global object

Can take any function and attach it as an attribute to the object : 'this' will be the object if called through the object (exception bind)
a.fn = some_random_function

a_function.call(this_object, 0, 1);
	calls the function with a certain this object and arguments
a_function.apply(this_object, [0, 1]);
	same but args is an array
	can be used to splat an array:
	a = [0, 1, 2]
	Math.min.apply(Math, a); // array converted to individual arguments

a_function.bind(thisObject, arg1, arg2)
	return a new function whose this is _permanently_ attached to thisObject
	and the first arguments always are the ones specified (arg1, arg2)
	returnedFunction() ~= originalFunction.call(thisObject, 0, 1);
	call to bind does not affect the original function
	stronger than call, apply, an_obj.bound_function()! => this won't change
	cannot rebind
	useful for setTimeout(object.method) => can avoid losing object being this with bind
	the new function does NOT have the properties of the original

a_function.bind(null)
	bind to the global object

if call a function without an object, this:
	- non strict: 	global object
	- strict: 		undefined



-- Constructor --
new aFunction()
	aFunction is (used as) a Constructor
	creates a new object, within the function 'this' is that object
	that object is returned
	BUT if return a object (type object only, no primitive) : will be the object returned
	aFunction() {...; return {};}
		{} will be the object created
	aFunction() {...; return "4";}
		not a valid object, the created "this object" will be returned
	if no argument, can omit the () : new aFunction <=> new aFunction()

var Constructor = function() {
    this.x = "x";	//within it, this is the new object which will be returned
};
o = new Constructor(); // new object
o.x === "x"

immediately called constructor
let user = new function(){
	this.x = ...
	...
};
	immediately called constructor function
	wrap object creation related code in a single place

new.target
	within the function
	if not called with new :	undefined
	if called with new :		= the function



-- Prototype --
object have prototype
prototype can itself have a prototype
attribute access looks up the prototype chain

myobj = Object.create(aPrototype);
	associate a new object with a prototype
	aPrototype can be null (avoid default keys if we use it as a map)
myobj = Object.create(aPrototype, propertiesObject);
	propertiesObject, same as Object.defineProperties
or
function Constructor() {}
Constructor.prototype = {
    number: 5,
    getNumber: function() {
        return this.number;
    }
}

Object.setPrototypeOf
Object.getPrototypeOf(anObject)
	gets/sets prototype of an object
anObject.__proto__
	deprecated
	dangerous to have : people use user supplied values as keys


AConstructor.prototype
aDefaultPrototype.constructor
anObject.constructor
	because of the constructor property on its prototype.

AConstructor.prototype = {};
	!changing the default prototype
	the constructor property on the new prototype object won't point to
	AConstructor
	{}.constructor = Object and not AConstructor
	solution:
	- add properties to the default prototype
	- 	


-- Prototype inheritance --
'this' in the method of a descriptor in a prototype is the child object
proto = {
  foo: function(){return this} // child.foo() : this === child
}
child = Object.create(proto);
child.foo(); //left part of the . dictated the this

writing on an object doesn't affect the prototype
proto : {a:1}, obj: {} (+its prototype is proto)
obj.a = 666;
proto : {a:1}, obj: {a: 666}

deleting on an object doesn't affect the prototype
proto : {a:1}, obj: {} (+its prototype is proto)
delete obj.a;
proto : {a:1}, obj: {} // no effect on the prototype

exception : accessor descriptor (get/set) in the prototype
reading/writing such property is actually a method call:
obj.accessor = 1;
actually does something like:
protoOfObj.getAccessor(1)
BUT this in the method is the object called and not the prototype

let proto = {
    get a() {
        return this._a; // this is child
    },
    set a(value) {
        this._a = value; // this is child
    }
}
let child = Object.create(proto);
child.a = 666; // set a()
console.log(child.a); // get a()

let proto = {
    stomach: [],
  
    eat(food) {
      this.stomach.push(food); // calls push on stomach of proto
      this.stomach = [food]; // set stomach on obj to food
    },
    
    set eat(food) {
      this.stomach = [food]; // 
    }
  };
 
let obj = Object.create(proto);
obj.eat("apple");


Builtins (Array, Number,..) have their own prototypes
those prototypes (Array.__proto__,..) have a prototype : Object.__proto__


Number.prototype.decuple = function() {
    return this*10;
}
	can change prototype of builtins
	sometimes used for polyfilling

Object.assign(target, ...sources)
	take all the enumerable own properties of the source objects and put it into target
	returns target
	shallow clone (property values of source are copied by value)
	order important (later overwrite earlier)
	??? how are properties handled? https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#description

Array.prototype.join.call(arguments)
	method borrowing


-- prototype inheritance with constructors --
const A = function(x) {
    this.x = x;
};
A.prototype.getX = function() {
    return this.x;
}

const B = function(x, y) {
    A.call(this, x); // call parent constructor
    this.y = y;
}
//alternative : B.prototype = Object.create(A.prototype) + set constructor property
Object.setPrototypeOf(B.prototype, A.prototype);
B.prototype.getY = function() {
    return this.y;
}

let b = new B("x", "y");
b.getX();


--- class ---
class MyClass {
    constructor(name) {
        this.name = name; // in the object
        console.log("constructor")
        //like constructor function : implicit this or explicitly return object
        return {}; 
    }

    myMethod() { // in the prototype
        console.log(this.name);
        this.otherMethod(); // call another method
        return 0;
    }
    
    get name() { // in the prototype
	    return this.name;
	}
	set name() {}

	[computerName](){} // in the prototype
	
	//class field
	//class field initialized before the constructor() runs
	xyz = 123; // in the object
	[computerName] = 123; // in the object (class property)	
}
typeof MyClass === 'function'
MyClass = MyClass.prototype.constructor
	Creates a MyClass function whose body is the constructor
	put the methods in the class's prototype
	like a prototype/function based type

let MyClass = class {...}
let MyClass = class User {...} //User visible inside the class only
	class expression
	can create classes dynamically (eg. class returned by function

differences from prototype/function based:
- must call with new
	MyClass() doesn't work
- string reprensentaiton different
- methods non enumerable by default
  like an implicit : Object.defineProperty(MyClass.prototype, "myMethod", {enumerable: false});
- all code within a class uses strict


aMethod() {
    setTimeout(() => this.hide(), 1000);   // ok (arrow functions share this)
    setTimeout(function() {this.hide()}, 1000); //SyntaxError
}

static property and method : same as assigning to the class
class User {
    static xxx = "xxx";
}
User.xxx = "xxx";

static method:
class User {
    static staticMethod() {
        console.log(this === User);
    }
}
User.staticMethod();
Just like doing:
User.staticMethod = function() {
    console.log(this === User);
}
	except here staticMethod is enumerable

cannot access static fields/methods through an instance


instance instanceof classOrConstructorFunction
	goes up the prototype chain of the instance
	check if one of those prototype is the prototype of the  class or constructor
	
1 instanceof Number == false
	does NOT work for primitives


SomeClass.prototype = xxx
	affects instanceof! (but not the objects created before)


class A {
	static [Symbol.hasInstance](obj) {
	  // return true or false;
	}
}
xxx instanceof A // the static method will be called
	instead of using the prototype chain, the static method is used
	result of the method is the final result of instanceof. 
	if a superclass of A has an Symbol.hasInstance (and A and the classes between A and it doesn't), it will be called


[Symbol.toStringTag] =  "Xxx"
	Used by the builtin toString
	instead of [object Object] => [object Xxx]


-- protecting fields / private --
_xxx convention : private, do not touch from the outside
protect field access:
class AClass {
  _waterAmount = 0;
  set waterAmount(value) { // accessor property to protect
    if (value < 0) {
      value = 0;
    }
    this._waterAmount = value;
  }
  get waterAmount() {
    return this._waterAmount;
  }
}

read-only field:
class AClass {
	constructor(power) {
	  this._power = power;
	}
	get power() {
	  return this._power;
	}
}

private field and methods
enforced by the language itself
!! recent (2021)
!! NOT visible in subclasses!
!! cannot access through this['#name']
class AClass {
  // a private field must be declared at the class level before it can
  // be used within a a method (this.#x)
  #privateField = 0;
  #privateMethod() {}
  
  constructor() {
  	//SyntaxError exception thrown
    this.#fieldNotDeclaredAtClassLevel = "xxx";
  }
  
  // access only within the class : this.#privateField, this.#privateMethod()
}
aClassInstance.#privateField = 0; // will fail
aCLassInstance.#privateMethod();  // will fail



-- inheritance --
single inheritance only (but mixin possible)

class Rabbit extends Animal {}
	inheritance
	sets Rabbit.prototype's prototype to Animal.prototype
class AClass extends xxx {} => xxx can be anything that returns a class (function,...)

super.method()
	call method in parent

//constructor in a subclass : 
constructor(name) {
    super(name) 
    this.x = "x";
}
	must call super()
	super() must be called before using this
	reason : the object created must be the one from above (to be set up correctly prototype wise)

constructor(...args) {
    super(...args)
}
	the default constructor does this


A constructor in a class that inherits from another class must retrieve the object it will work on (and return) from the superclass's constructor
Consequences:
- must call super() (to get the object)
- The class fields of a class are only initialized after super() has been called in the constructor. (need the object before we can initialize the fields)

In a constructor the class fields of the super classes and the current class are initialized but not the one of the subclasses
class Animal {
    name = 'animal';
    roar()
    constructor() {
        console.log(this.name); //prints animal
    }
}
class Rabbit extends Animal {
    name = 'rabbit';
}

BUT the methods of the subclasses are available
class Animal {
    name = 'animal';
    say(){
        console.log(this.name)
    }
    constructor() { // 1) constructor runs
    				//    class fields of Animal initialized but NOT Lion
        this.say(); // 2) say of Lion called 
    }
}
class Lion extends Animal {
    name = 'lion';
    cry = "roars!"
    say() {
        console.log(this.name, this.cry); // 3) prints animal undefined
    }
}
new Lion()
	undefined because : 
		parent constructor calls overridden method in subclass
		class fields not yet initialized in subclass
	=> careful in constructor when calling methods!

there is some magic in methods (defined in class and plain objects) to make super() work as expected
hidden [[HomeObject]] property so that super() points to the right object (in the inheritance tree).

anotherObject.aFunction = object.aMethod;
anotherObject.aFunction()
	will break if aMethod has super()


- two [[prototype]] chains -
class Animal {}
class Rabbit extends Animal {}

Prototype chain for instances/prototype objects:
console.log(Object.getPrototypeOf(Rabbit.prototype) == Animal.prototype);
a prototype can have a prototype : the parent prototype
	makes inheritance work
	obj.xxx if not found in obj then go to obj's prototype then obj's prototype prototype...

Prototype chain for classes:
Classes have also their prototype chain!
Makes static work with inheritance
console.log(Object.getPrototypeOf(Rabbit) == Animal);

class Rabbit {}
class Rabbit extends Object{}
	difference: with extends static methods of object work on Rabbit
	eg. Rabbit.getOwnPropertyDescriptor
	because : extends sets up the prototype chain _on the classes_ (aka functions)

built-in objects (Array, Map,..) have the first chain but not the second
Object.xxx not available in Array.xxx


- built-in inheritance -
Can inherit from built-in types
class PowerArray extends Array {
	...
}

aPowerArray.filter/map/... => type of array returned will be PowerArray!
those methods check the type of the object when creating a new one

static get [Symbol.species]() {
  return Array;
}
	within a class that inherits from a built-in type
	can specify which class will be used when filter/map/... create a new object


-- mixin --
Inject behaviour into a class
let someMixin = {
  // methods here
}

class SomeClass {}
Object.assign(SomeClass.prototype, someMixin);

limitations:
- instanceof theMixin doesn't work
- cannot use accessor. Writing to an accessor property defined in the mixin erases it with a data accessor in the object
- cannot use super

better to make a class and inherit from it

--- Primitive conversion ---
no operator overloading (redefine '+' operator in obj1 + obj2)
but can control (some) conversions of obj (to string/number/default)
obj->boolean : always true, NO control
	eg !obj, obj === true (but NOT obj == true which uses default), Boolean(obj)
obj->string : can control
	"string" hint
	eg alert(obj), anotherObj[obj], String(o)
	! NOT "a string" + obj
obj->number : can control
	"number" hint
	eg obj1 - obj2, Number(obj), obj1 > obj2, 0 > obj, "str" > obj
default conversion
	"default" hint
	eg obj1 + obj2, "str" + obj, if (obj == 1)
	used when not sure if number or string should be used
	in practice : all built-ins object convert to number (except date), we should do the same => treat number and default hints the same

Two ways
1. Modern
o = {
    [Symbol.toPrimitive](hint) {
        if(hint == 'string'){
            return "I am o!"
        }else{ // 'number' or 'default'
            return 0;
        }
    }
}
	Checked to see if exist first, used if exists
	must return a primitive type, error if return object

2. older
o = {
    toString(){
        return "I am o"
    },
    valueOf(){
        return 99;
    }
}
	checked if no Symbol.toPrimitive
	"string" hint : check toString then valueOf
	"number" "default" hints : check valueOf then toString
	can implement only one : eg toString
	must return primitive, result ignored if not a primitive (as if method didn't exist)

Since we can't return objects nor know which exact operation the conversion is for, the conversion system is of limited use (especially default/number).	
If want to keep things simple : 
-can implement only toString, will always be called (except boolean conversion). Good for debugging.
-States that objects not designed to perform operations on it.



alert("msg")

prompt("msg", displayed_default)
	return null if cancel

confirm("msg")
	return true or false



--- try catch ---
try {
    a;
} catch(err) {
} catch { // or
    err.name;
    err.message;
    err.stack;
    
    //typical pattern : handle what we want, rethrow the rest
    if(err instanceof SyntaxError){
    	// handle
    }else{
    	throw err;
    }
}finally {
    console.log("finally");
}
	watch out for block scope : what is declared in try isn't visible in catch/finally

throw new Error("msg")
	can technically throw anything
	should throw something inheriting from Error

try {
    return 0;
}finally {
	// return in finally takes precedence over return
	//swallows exceptions
    return 2; 
}

function MyError(message=""){
    this.name = "MyError";
    this.message = message;
}
MyError.prototype = new Error();
	custom exception
  
class FormatError extends SyntaxError {
    name = this.constructor.name;
    constructor(...params) {
        super(...params)
    }
}
	better custom exception
	can add parameters to the constructor : additional data
  
process.on("uncaughtException", function(err, origin){}
	global handler (if exception was not caught)
	node

window.onerror = function(message, url, line, col, error) {}
	global handler (if exception was not caught)
	browser
	doesn't seem to work for exceptions created from the browser console
	used to send those error to an error logging service
	generally not used to show errors to user

--- Global object ---
window in browser
global in node
globalThis in browser and node (since 2019)

var foo = x;
console.log(window.foo);

global.foo = 1
console.log(foo);
	bad to put variables in the global object
	useful for polyfill

value of this at the top level:
browser:
	strict/non strict : window
	module (type="module") : undefined

node:
	module.exports


--- modules ---
Will see ES modules
other systems:
- AMD
- CommonJS (node.js default)
  require()
  default on node. 

Node:
to use ES modules in node:
- use .mjs extension
- "type": "module" in package.json

Otherwise : SyntaxError: Cannot use import statement outside a module

Browser:
to use ES modules in browser:
Must use type="module" in the <script>
<script src="a.js" type="module"></script> //
<script type="module">...</script> //

Otherwise : SyntaxError: Cannot use import statement outside a module


only runs the code of a module once, even if imported multiple times

Changes to module compared to standard script:
- a module has its own top-level scope
  (can still share data : import/export or global object)
- this is undefined in the top-level
- can import export
- a module is always in strict mode
- import.meta contains info about the module
	import.meta.url

browser specific:
- module <script> are always deferred
	asynchronous load
	runs in order before DOMContentLoaded
- defer behaviour works on inline script!
- can use async attribute on inline <script> if it is type="module"
- external <script>s for the same src url : run only once
- requires CORS if src is cross origin

bare module?

usually don't mix named and default exports


-- named export/import --
export
export function xxx(){}
export class Xxx {}
export let xxx = ...;
export const xxx = ...;
	export during declaration

...
export {sayHi, xxx};
export {xxx as yyy};
	export apart from declarations

import
import {xxx} from './module.js'
import {xxx as yyy} from './module.js'

import * as mod from './aModule.js'
	import all
	mod.xxx
	avoid:
		prevent bundler optimizations (remove unused dependencies)
		longer names
		easier to read/refactor

-- default export/import --
+ many small modules, only one thing per module easier to understand
- multiple imports can use multiple names
export default function foo(){}
export default aVariable; // cannot do export default let aVariable = 1; two lines required
export default class {}
export default 123;
	name not required for default export

export {xxx as default, yyy}


import module from './module.js'
	if export default used
	rule : 	name of variable is the name of the module
			avoids importing multiple things under different names

import * as user
	if default : user.default


-- export something we import --
useful for facade, public interface of a package
elements NOT available in current file (sayHi, User are not available)

export {sayHi} from './say.js'
	named export
export {default as User} from './user.js'
	exports the default

export * from './module.js'
	export everything named
	does not export the default
	to export default : see above

-- dynamic import --
static imports : cannot choose file name dynamically, cannot import conditionnaly
dynamic import : can choose file name, can import conditionnaly
import()
	returns a promise containing the import
import(modulePath)
  .then(obj => obj is the module object)

let {hi, bye} = await import(moduleName);

let obj = await import('./say.js');
let say = obj.default;
or:
let {default: say} = await import('./say.js');



--- eval ---
eval(code as string)

let value = eval(...)
	value is the value of the last statement

eval'ed code runs in non strict mode by default
to run in strict mode : eval("\"use strict\"; ...);

can see/set variable of the environment where eval() is called
(use variable, change them)
bad programming practice
fail with minifier

non use strict (parent code):
	can create new variables => visible in context where called

use strict (parent code):
	can create new variables => not visible in context where called
	(can still access/change existing variables)

window.eval
global.eval
	the context is the global object

function foo() {
    global.eval("aaa = 1;");
    console.log(global.aaa); // 1
    console.log(aaa); // 1
}
foo();

consider new Function(code) instead

--- JSON ---
RFC4627
a JSON string called : JSON-encoded, serialized, marshalled.
differences from object literals:
	strings are double quotes
	property keys are within quotes
	no properties with undefined value
	no function
	no Symbols
	no comments
	
JSON.stringify(value)
JSON.stringify(value, replacer)
	replacer : array of string or function
JSON.stringify(value, ["a", "b"])
	in objects only properties with these names will be encoded
JSON.stringify(value, function(key, value){})
	! first call to it will have empty key and the object passed to stringify as value
	this is the object which possess the property
	return undefined to skip property
	return a value : that value will be the one encoded
JSON.stringify(value, replacer, space)
	space
	0 = one-line compact
	1+ = on multiple lines + size of indentation

toJSON
	function attached to an object
	returns string representation
	used by stringify


JSON.parse(str)
JSON.parse(str, reviver)
	reviver is a function(key, value)
	convert the string value back into js representation
	returning undefined = do not deserialize that property
	this is the object that will be created
		includes not yet handled properties, transformed properties
		not the properties that have already been rejected for the current object
	eg: dates



--- timeout interval ---
timerId = setTimeout(func, delay, arg1, arg2,...)
timerId = setInterval(func, delay, arg1, arg2,...)
clearTimeout(timerId);
clearInterval(timerId);
	both clear methods do the same thing (share the same range of timeId)

this is the window object (Timer object in node)

zero delay scheduling: delay == 0. wait for the current code to stop running before running it

careful: 
- memory leak : everything func refers to (variables outside the function) won't be GC'ed until clearTimeout has been called

- delay is NOT wait 'delay' amount of time after last execution before calling it again
	it is : call func every 'delay'
	problematic if the function is slow => short/no pause between calls
	can be fixed by  rescheduling the calls ourself with setTimeout

- can lose the this
	setTimeout(object.method, 1000)
	method will be called without the object. Wrong this.
	fix with bind

- if multiple scheduled functions have their delay elapsed and are ready to run
  order is in order of in which setTimeout was called
let a = setTimeout(function ( ) {console.log('a');}, 1);
let b = setTimeout(function ( ) {console.log('b');}, 0);
//...
	the first function to run is not deterministic:
	-a if more than 1ms is elapsed before the engine decides which function to run
	-b if ready to run a function quickly

- in browsers, if repeat the same action 5+ times : there is a 4ms delay before it runs again even if the delay is 0
	historical for browser compatibility



--- Regex ---
new RegExp("pattern", "flags");
/pattern/gmi

flags
i	case insensitive
g	global, all matches not just the first
m	multiline mode, ^ and $ match at beginning/end of line not just string

str.match(regexp)
	if g flag : array of matches (simple strings)
	if no g flag: array representing a single match (details on the match)
		[0] = matched, [1] first group,..
		length	number of indexes (result+groups)
		index
		input
		groups ???
	if not match: null !!! (g or no g)

str.matchAll(regexp)
	regexp must have the g flag
	returns an iterable of arrays representing a match
	returns empty array if no match

str.replace(regexp, replacement)
	if no g :	replace first
	if g: 		replace all
	replacement accepts special value which will be replaced by part of the match

aRegexp.test(string)
	is there a match

str.split(regexp)
	returns array

str.search(regexp)
	position of first match or -1









--- dev tools ---
$0 in console
	last element selected

inspect(aDOMNode)
	selects/inspects the element

console.log(DOMElement)
	shows DOM tree
console.dir(DOMElement)
	shows properties (like an object)



--- ID-named global variable ---
BAD
<div id="foo">hello</div>
<script>
    foo.textContent = "new content";
    window.foo.textContent = "new content";
</script>
    id-named global variable / variable on the window access
    Named access on the Window object
    all nodes with id are added to the window object
    (and thus globally available)
	Crazy (bad) because
	- it can clash with window's default properties
		(window's built-in properties win in that case)
	- it can clash with global variables set in js
		(global var wins in that case)
    https://stackoverflow.com/questions/3434278/do-dom-tree-elements-with-ids-become-global-variables
    https://html.spec.whatwg.org/multipage/window-object.html#named-access-on-the-window-object



--- window ---
in browsers the window object is
- the global object
- the way to control the browser

BOM Browser Object Model
represents objects to interact with the browser
(except the document itself which is the DOM).
eg.: location, navigator,...



--- DOM ---
Document Object Model
object representation of document

There also is the BOM (browser related objects)
There also is the builtin js APIs

types of nodes : 
- element node
- text node
	contains only text
	no chidren (always leaf)
- comment node
- document node (the access point)
... (12 types in all https://dom.spec.whatwg.org/#node )

putting nodes after body : automatically moved to the end of body

html and body nodes are always generated

<x>
 <y>
 	=> text node containing the newline + space between x and y!
	there are text nodes for new lines and space between elements but they are not shown in browser tools
	xxx.childNodes lists them


-- DOM objects --
                    โโโโโโโโโโโโโโโโโ
                    โ EventTarget   โ
                    โโโโโโโโฒโโโโโโโโโ
                           โ
                    โโโโโโโโดโโโโโโโโโ
       โโโโโโโโโโโโโบโ     Node      โโโโโโโโโโโโโโโโ
       โ            โโโโโโโโโโโโโโโโโ              โ
       โ                   โฒ                       โ
       โ                   โ                       โ
โโโโโโโโดโโโโโโโโโ   โโโโโโโโดโโโโโโโโโ      โโโโโโโโโดโโโโโโโโ
โ     Text      โ   โ   Element     โ      โ    Comment    โ
โโโโโโโโโโโโโโโโโ   โโโโโโโโโโโโโโโโโ      โโโโโโโโโโโโโโโโโ
                           โฒ
                           โ
                    โโโโโโโโดโโโโโโโโโ
        โโโโโโโโโโโโบโ HTMLElement   โโโโโโโโโโโโโโโโ
        โ           โโโโโโโโโโโโโโโโโ              โ
        โ                  โฒ                       โ
        โ                  โ                       โ
โโโโโโโโโดโโโโโโโโโ  โโโโโโโโดโโโโโโโโโ       โโโโโโโโดโโโโโโโโโโโ
โHTMLInputElementโ  โHTMLBodyElementโ       โHTMLAnchorElementโ
โโโโโโโโโโโโโโโโโโ  โโโโโโโโโโโโโโโโโ       โโโโโโโโโโโโโโโโโโโ

EventTarget
	addEventListener
	removeEventListener

Node
	parentNode, childNodes, firstChild,...
	nodeType
	nodeName
	textContent


Element
	tagName
	children
	nextElementSibling,...
	id
	className
	querySelector
	innerHTML
	hidden

HTMLElement

HTML<Type>Element
html attribute => DOM element property is not a one-to-one mapping



nodeType
	old school way to determine type of DOM Node
	number
	Node.ELEMENT_NODE(1), Node.TEXT_NODE(3), Node.COMMENT_NODE(9), 

nodeName
	string of the name
	always uppercase
	for any node (including text, comment,..)
tagName
	for Element
	tag as-in HTML tag
	(not on document object which is a node)


-- navigation properties --
document is the parent of
	document.doctype
	document.documentElement (html)

html is the parent of 
	document.head (shortcut)
	document.body (shortcut)

navigation attributes
from a node, access to other nodes:
parentNode
	parentElement is identical except html.parentElement is null.
	reason : document is not an element node


-- navigation methods --
xxxElementxxx means the nodes of type element only (no text, comment,...)

previousSibling previousElementSibling
nextSibling nextElementSibling

firstChild firstElementChild
lastChild lastElementChild
childNodes (all types of nodes)
children (elements nodes)

DOM collections:
coming eg. from childNodes
- not an array but iterable and indexable
- most often dynamic (changes in DOM reflected in the collection object)
  sometimes static (eg. querySelectorAll)


document.getElementbyId
(also id as global var, see below)

document/element.querySelector(cssSelector)

document/element.querySelectorAll(cssSelector)
	static list

document/element.getElementByTagName	element of a certain type (div,..)
document/element.getElementByClassName
document.getElementsByName				elements with the given value for the name attribute (not really used anymore, forms can have name see document.forms)
	these are replaced by querySelector

element.matches(cssSelector)
	does the element match the given css-selector

element.closest(cssSelector)
	nearest ancestor (including the element itself) matching the selector

element.contains(elementB)
	does element contain or is elementB


-- element properties --
innerHTML
	HTML in the element as a string
	not the HTML of the element itself
	can change the HTML content!
		xx.innerHTML = '...'
		modifies the object
		rewrites everything.
		Lose state, text input, events,..
		scripts inserted are NOT executed

outerHTML
	includes the HTML of the element itself
	can change the element
		doesn't change the content
		replaces the element with a new one!
		old object is still around but not attached
			aDiv.outerHTML = '...';
			aDiv// still here with the old content

textContent
	text inside (no tags)

nodeValue data
	for types other than Element (comment, window.document)

value
	value inputted in input, select, textarea,...

hidden
	hidden = true
		sets the [hidden] attribute on the element
	remove element from the DOM (changes layout)


-- HTMLElement properties / HTML attributes --
attributes in the html maps to properties on objects of the DOM

two ways to access the attributes set on html elements from the html object:
- through specific properties (eg. id="x" => anObj.id)
  actual value
- through attribute api below (getAttribute,..)
  value set on the HTML

value set on the HTML may not match the actual value : 
- css
- changed by js
  elem.attributes.attr = "x" doesn't change value of elem.getAttribute("attr")
  elem.getAttribute("attr") changes value of elem.attributes.attr = "x"

properties may not have the same value as the attribute:
- checked: converted to boolean
- href: full URL
- value: current value set by user instead of attribute value


hasAttribute(name)
getAttribute(name)
setAttribute(name, value)
removeAttribute(name)
	case insentive name!
	value is always string

attributes
	array of attributes
	live

<... data-xxx = "...">
	custom data attribute
	add data to html elements
	alternative to classes
	guaranteed never to clash with standard properties
	typically used by javascript
	accessible from elem.dataset
	converts name : [data-abc-def] <=> dataset.abcDef



--- create / manipulate html ---
document.createElement(tagName)
document.createTextNode(text)
	aka CharacterData, aka Text
document.createComment(text)

node.cloneNode()
	same as cloneNode(false)
	clones a node
	only the node itself, not its content
node.cloneNode(true)
	deep clone

node.remove()


-- add node to the DOM --
anElement.append(node, node2) 
prepend()
before()
after()
replaceWith()
	arg: node or string
	one or multiple args
	if string : will create a text node not an html one (escape)
	can also be used to move an existing node

anElement.insertAdjacentHTML(where, htmlString)
	turns the string into html elements (like innerHTML)
insertAdjacentText(where, text)
	creates a text node
insertAdjacentElement(where, element)
	must be an element
where
	"beforebegin"	before the element
	"afterbegin"	beginning of the element
	"beforeend"		end of the element
	"afterend"		after the element


parentElem.appendchild(node)
parentElem.insertBefore(node, nextSibling)
parentElem.replaceChild(newNode, oldNode)
parentElem.removeChild(node)
	old
	returns the appended node

document.write
	old
	only works when the page is loading (inline scripts)
	if called after : erases all content



new DocumentFragment()
designed to contain nodes (can contain multiple roots)
can use prepend, append on it
can pass to prepend, append,... => will add the content
alternative to an array of elements : x.append(...arrayOfNodes)



--- class ---
element.className
	full class attribute as a string
	read/write
	(className not just class because class was reserved in js)

element.classList
	iterable, indexable list of classes
x.classList.add(className)
x.classList.remove(className)
x.classList.toggle(className)
x.classList.contains(className)
	modify classes
	! div.classList.add(null/undefined) => adds a class "null"/"undefined"!
	! no empty string to add


--- style ---
elem.style
	corresponds to the style attribute
	! only the style attribute
	doesn't know what is set through css
	doesn't know what is computed
	<xxx style="display:none">
	attribute name modified intro property:
		background-color => backgroundColor
		(like custom data attribute)
eg. elem.style.display = "none";

elem.style.someAttribute = "";
	remove and style as if we never set a value

elem.style.cssText
	full style attribute as a string	
	read/write


-- computed style --
getComputedStyle(element)
getComputedStyle(element, pseudo-element)
	return an object similar to element.style
	read-only
	contains all the computed properties
	the actual resolved values (xxx% => xxxpx)



--- size ---
values 0/null if 
-not displayed (display:none, hidden=true)
-not attached to the DOM

prefer the properties below rather than getComputedStyle
getComputedStyle:
- affected by box-sizing
- may be a value such as "auto" and not a size in px

offsetParent
	closest positioned parent (or body)
	cf position: absolute
offsetLeft offsetTop
	offset to offsetParent

offsetWidth offsetHeight
	content+padding+border (not the margin)
	includes scrollbar if any
	outer width

clientLeft clientTop
	size of border left/top
	also includes scrollbar (adds to the size of the border)

clientWidth clientHeight
	content+padding (not the border, scrollbar, margin)

scrollWidth scrollHeight
	useful in case of scrolling
	not the size of the part visible but
	the entire size of the element, including the one not visible due to scroll

scrollTop scrollLeft
	how much has been scrolled


document.documentElement.clientHeight
document.documentElement.clientWidth
	size of the window (viewport)
	without the scrollbar
		window.innerWidth window.innerHeight to get value with the scrollbar


window.pageXOffset
window.pageYOffset
window.scrollX
window.scrollY
	current scroll position
	read-only

window.scrollTo(x,y)
	scroll to a position

window.scrollBy(x,y)
	scroll relative to current scroll position

elem.scrollIntoView()
elem.scrollIntoView(true)
	scroll element into view (top of the page)
elem.scrollIntoView(false)
	scroll element into view (bottom of the page)

document.body.style.overflow = "hidden"
document.body.style.overflow = ""
remove scrollbar/scrolling
restore it



-- coordinates --
two systems:
-relative to the viewport (window)
 aka client
 changes when scrolling
-relative to the document
 aka page
 not affected by scrolling

same when no scrolling.
when scrolling : 
	window => changes (as content scroll through the window)
	document => doesn't change


elem.getBoundingClientRect()
	returns an object with:
		x y
		width height
		top bottom
		left right
	relative to the client : window
	can be negative : scrolled past the element
	can convert to page related coordinates by using window.pageYOffset !

document.elementFromPoint(x, y);
	most nested element at (x, y)
	relative to client
	(x, y)must be within the viewport



--- Events ---
<div onclick="js here">
<div onclick="aJSFunction()"> //parens
anElement.onclick = aFunction //no parens
	only one listener can be attached
	this is the element

anElement.setAttribute('onclick', function (){}); 
	doesn't work
	value of setAttribute is a string

elem.addEventListener(
    "click", 						//event
    callbackOrHandlerObject, 				//handler
    {								//options
        once: false,
        capture: false,	// handler runs during the capture phase instead of the bubbling phase
        passive: true, // cannot/will not prevent default
    });
elem.addEventListener("click", x, true);
	true like {capture: true}
	
	within the handler: this is currentTarget
	(reminder : arrow functions do not have their own this)

elem.removeEventListener("click", fn)
	! if added a listener with passive true : must remove it with passive true
		removeEventListener("click", fn, true)

some events only work with addEventListener
eg.: DOMContentLoaded, focusin, focusout

handlers run in the order they where added

callback function:
	called a handler
	this = the element (requires a function, doesn't work with arrow function)
	first argument = Event object
	always has an automatically created event variable containing the event
		(as if the callback was wrapped in a function with an event argument)

handler object
	object with an handleEvent method that works like a callback function

anEvent.type
	type of event ('click',...)
anEvent.currentTarget
	element currently handling the event
anEvent.target
	element initially stated to handle the event
anEvent.clientX
anEvent.clientY
	coordinates of the cursor
	if applicable


-- events --
click		
mousedown	
submit		form
keydown
contextmeny	right-click
touchstart
touchmove

-- bubbling --
event on an element?
handlers of element run
then handlers of parent
then handlers of ancestors all the way up
bubble up to document (sometimes window)

most events bubble
events that do not bubble:
-focus

eventObject.target
	tells on which element the event happened

this, eventObject.currentTarget
	object with the handler currently running



event.stopPropagation()
	prevents event from being handled by ancestors
	(other handlers attached to the current element still run)

event.stopImmediatePropagation()
	prevents event from being handled by ancestors
	AND prevents other handlers of the current elment to run

stopping propagation should generally not be used

Sometimes it is a good idea to wait for all potential handlers to have run before performing an action.
Eg.: detect a request to open a menu. Wait for all handlers to have run before opening the menu.
Solution : open the menu in a 0 delay setTimeout.

-- capturing --
1) capture phase
	event goes from root down to the ancestor elements of the element that triggered the event
2) target phase
	event reached the target element
	(doesn't matter if capture true or false)
2) bubbling phase
	event bubbles up the ancestors

capturing should generally not be used

elem.addEventListener('type', handler, {capture: true});
elem.addEventListener('type', handler, true);
	runs the handler during the capture phase

a handler capturing on the targeted element is like a normal bubbling handler (runs after other handlers registered earlier)

to remove an handler must use the same phase
eg.:
elem.addEventListener('type', handler, {capture: true});
elem.removeEventListener('type', handler)
	handler NOT removed

event.eventPhase
	tells which phase the handler is registered for
	Event.CAPTURING_PHASE
	Event.AT_TARGET
	Event.BUBBLING_PHASE


-- event delegation --
delegate event handling to a parent element

table.onclick = function(event) {
  // target may not be td but an element inside td, retrieve the td
  let td = event.target.closest('td'); 

  // if target is not inside any td
  if (!td) return;

  // make sure we reached the td of the current table (and not a parent table)
  // case of nested table and td lying outside the table
  // make sure closest() didn't reach outside of table
  // example:
  // td
  //   table
  //      elem // <-- receives click. closest matches to td outside of table
  if (!table.contains(td)) return;

  // found the correct element
  // can do the work it
  highlight(td);
};
	handle the clicks on td elements in a single place at the table level


-- attribute based behaviour --
<button data-action="load">Load</button> //

class Menu {
  constructor(elem) {
    this.elem = elem;
    // without this line, this within onClick would be the DOM element
    elem.onclick = this.onClick.bind(this);
  }

  save() {...}
  load() {...}

  onClick(event) {
    let action = event.target.dataset.action;
    if(action) {
      this[action];
    }
  }
}
	make the link between markup (action custom data attribute)
	and functions


-- behaviour pattern --
setting some markup in an element change its behaviour
js code implementing that behaviour is in an event handler at the document level
allows implementing feature without ugly js<=>DOM wiring

// set up the HTML
<input type="button" value="1" data-counter>

// single handler in the container (here root)
document.addEventListener('click', function(event) {
  // check if we want to handle the event (by checking the target)
  if(event.target.dataset.counter != undefined) {
    event.target.value++;
  }
}
	set-up handler once at document level
	can then add the attribute wherever we want to change behaviour
+ decoupled, easy to understand
- performance (code runs for events we do not care about)
  event may have been stopped by some intermediary (event.stopPropagation())


-- default actions --
click link : navigate to page
click form's submit : submit form
select text : text selected
...

prevent a default action, in event callback:
-event.preventDefault()
-return false;
	only if handler added with onxxx
	eg.:
		<a id="link" href="hi" onclick="return false">hello</a> //
		link.onclick = ()=>false;


addEventListener('...', fn, {passive: true});
	signals that the handler will not call preventDefault() (or return false)
	(if call anyway : ignored)
	important for some events where waiting to see if some handler will prevent the default action will cause an operation not to be smooth
	eg.: touchmove, touchstart
	default is true for some browsers/events:
		chrome and firefox for touchstart, touchmove

event.defaultPrevented
	has preventDefault() (or return false) bene called
	by us or by a previous handler


-- manually generated events --
can generate events from JS

new Event(type, options);
	type: string ('click',...)
	options:
		bubbles: true/false (default false)
		cancelable: true/false (default false) (can prevent default action?)

specific built-in types:
UIEvent
FocusEvent
MouseEvent		(click)
KeyboardEvent
...

elem.dispatchEvent(e)
	"runs" the event
	returns false if default has been prevented
	new event is 'run' immediately, current event handling resumes after the event has finished
	wrap dispatchEvent call in a setTimeout 0 to schedule the new event after the current one.

avoid generating browser events (like click,...) : hacky, bad architecture
	ok when: 3rd party needs an event; automated testing	

event.isTrusted
	true if generate by a real user action
	false if script generated event

example:
	// must use addEventListener because there is no onxxx for custom events
	document.addEventListener('foo', ()=>console.log(event));
	anElem.dispatchEvent(new Event('foo', {bubbles: true});

new MouseEvent('click', {bubbles: true, cancelable: true, clientX: 100, clientY: 100});
	better to use the correct class
	

new Event('click', {clientX: 123}):
	theEvent.clientX === undefined
	unknown properties in the options parameter for this type of event are ignored


-- custom events --
we can create our own components and have them generate custom events

new CustomEvent('hello', {detail: {anything: "I want"}});
	does not exist in node!
event.detail
	data passed as detail into the option object
	is available in event.detail

our custom even can have a (cancellable) default action:
code for default action runs after the dispatchEvent if there was no cancel
if elem.dispatchEvent(myEvent) returns false
	default action has been prevented in some handler
	do not run the default action.
	requires cancelable: true in the option object of the event

eg.: parent-wide context menu and child specific context menu.
child handler : implement local context menu and prevents default so that parent doesn't overwrite
parent handler: check if defaultPrevented before setting the menu



-- handling touch/click input --
3 ways:
- mouse events (mousedown, click,...)
  also triggered when touch
- touch events (touchstart, touchend, touchmove)
  touch-specific.
  Annoying to have to handle both mouse and touch events
- Pointer events (pointerdown, pointerup, pointermove,...)
  works for all kinds of pointing devices (mouse, touch, stylus)
  supports multi-touch, pressure, width/height


-- mouse events --
mousedown mouseup
	clicked while the pointer was on the element
	preventing default on mouse down prevents selecting text
	(click and drag or double-click)

mouseover mouseout
	move on off the element
	element itself not children, bubbles
mouseenter mouseleave
	move on off the element
	element or child, does not bubble
mousemove
	every mouse movement detected over an element
click
dblclick
	rarely used
contextmenu
	right-click (or special keyboard key)


order: mousedown -> mouseup -> click (*2) -> dblclick


event.button
	which button was pressed
	0 primary
	1 middle
	2 right
	3 back
	4 forward

event.shiftKey
event.altKey
event.ctrlKey
event.metaKey	Cmd on mac (mac generally uses it instead of ctrl)
	when checking for ctrl:
	ctrlKey || metaKey

event.clientX
event.clientY
	window-relative coordinates

event.pageX
event.pageY
	document-relative coordinates


mouseover
	target : element the cursor came onto
	relatedTarget : element that the cursor left
mouseout
	target : element that the cursor left
	relatedTarget : element that is now under the cursor

- only on a single element at a time: 
  if cursor goes from a container parent to a child 
  it will mouseout when leaving an element for a whild
- bubbles: : parent will receiver mousover event of children
- relatedTarget can be null : cursor came from / went  outside the window
- may skip elements if cursor moves fast


mouseenter
mouseleave
	target
	relatedTarget
- transition to descendant does not count as leaving
- does not bubble


-- pointer events --
works for all kinds of pointing devices (mouse, touch, stylus)
Can replace mousexxx events by pointerxxx events
	pointer events have the same properties as mouse ones (+ some more)
	mouse will still work
	touch support will improve (but may need some work)

pointer event properties
pointerId
	unique ID of the pointer
	to handle multiple pointer (eg. touch + stylus)
	touch : one id per finger
pointerType
	"mouse"
	"pen"
	"touch"
isPrimary
	primary pointer
	the first finger in multi-touch


-- keyboard events --
keydown
keyup

keypress
	deprecated
	a mess with too many browser incompatibilities

event.code
	physical keyboard code
	represent a key at a certain location
	no matter the layout (a on azert, q on qwerty)
		was not the case on my firefox!
	useful for games
	not impacted by the case
	"KeyA", "KeyZ", "Digit0", "Digit9", "Enter", "Tab", ...
	(not to be confused with charCode)

event.key
	(corresponding) character
	"A", "a", ...
	"Dead" for ^.. ยจ..
	(not to be confused with keyCode)

keydown
event.preventDefault()
return false (onxxx)
	prevents normal action associated with the keyboard
	character added, character deleted, page scroll, save,...


-- scroll event --
'scroll' event



--- form ---
document.forms
	collection of all the forms

document.forms[0] and can iterate

document.forms.xxx
document.forms["xxx"]
	if <form... name="xxx"> or 	<form... id="xxx">


form.elements
	collection of all the form inputs (input, select,..) and fieldset
	no matter how deeply nested
	no other html elements (div,...)

form.elements[0] and can iterate
	
form.elements.xxx
form.elements["xxx"]
form.xxx (also)
	the element if one control
	a list if multiple controls with that id/name (for radio/checkbox)
	(if change name of an element
		only new name in form.elements
		old and new name in form.old form.new)

aFieldSet.elements
	fieldset have their own elements property like form
	fieldset appear in form.elements


input.form
	the form the input/fieldset belongs to

input.value
	value (as string)


checkbox.checked
	boolean value 


aForm.submit()
	submit the form

-- select --
select.options
	collection of the <option>

select.value
	the value of the [value] of the selected option (<option value="xxx">)
	the content of the option if no [value] (<option>xxx</option> // )

select.selectedIndex
	index of the currently selected option

select.value = xxx
select.selectedIndex = 0

anOption.selected = true
	set the value of a <select>

new Option(text, value, defaultSelected, selected);
	creates a new <option>
	syntactic sugar over document.createElement('option') + setting options


-- focus  blur--
(see also tabindex and autofocus HTML attributes)
'focus'
'blur'
	events
	do not bubble (but captures)
	event raised after the focus has been gained/lost
		preventDefault() will not prevent changing the focus

'focusin'
'focusout'
	same as focus/blur but bubbles
	! onfocusin onfocusout do not work

elem.focus()
elem.blur()
	focuses/blurs
	firefox : cannot focus/blur from a blur/focus event

document.activeElement
	currently active element


-- form data update events --
change
	triggered after element change
	text field : change text then lose focus
	checkbox, dropdown list : select a value

input
	every time the value change
	text field : triggered any time there is a change (type a letter, cut, delete,...)

cut
copy
paste
	can prevent cutting/copying/deleting with preventDefault()

event.clipBoardData.getData('text/plain')
	get text to be pasted
	paste only
	not in cut/copy because text hasn't been copied yet
		check what is selected to get the text to be copeid
	! clipboard data is pretty complex (handles file copying)


submit
	event when submitting a form (submit button, enter on field)
	NOT when aForm.submit()
	can be used to check the validity of the data
	can prevent submission : event.preventDefault()
	a click event on the submit button is also dispatched (even if it wasn't clicked!)



--- page state ---
! if event occured before we register : the handler will never be called

DOMContentLoaded
	HTML loaded, DOM of HTML built
	can still load images, stylesheets, async scripts
	if execute js code, possible that : image size 0, stylesheet not applied,...
	on document (bubbles to window)
	!MUST use addEventListener (onDOMContentLoaded doesn't work)
	handler will NOT trigger if it is attached after the event

load
	everything has ben loaded (image, style, async script)
	stylesheet applied, size of images known
	!on window, NOT document
	also on images

beforeunload
	can ask for confirmation
	return false will trigger the confirmation message
	!event.preventDefault() does not always work (chrome)!!!
	on window

unload
	about to leave
	can still perform limited operations, nothing that takes time
	on window
	navigator.sendBeacon(url, data) CAN be used to send data (even if it takes time)
		broken on safari, must use another event

document.readyState
	'loading'		before DOMContentLoaded
	'interactive'	after DOMContentLoade before load
	'complete'		after load

pattern : want to run code after DOMContentLoaded but don't know if it has happened or not. Eg.: async script
solution:
if(document.readyState == 'loading') {
	//schedule
	document.addEventListener('DOMContentLoaded', work);
} else {
	work();
}

readystatechange
	track change of value of document.readyState
	old, generally use DOMContentloaded and load nowadays
	!on document, doesn't bubble


-- ressource loading state --
onload
	successful load
	only check the loading, there could be further problem (syntax error in the script,...)
onerror
	an error occured

won't trigger if attached after the load

for image, iframe, external style, external script,...

iframe
	onerror unused
	onload always triggers (even if unseuccessful)

img
	loads as soon as an image element gets an src



--- MutationObserver ---
new MutationObserver(aCallback(mutationRecordList, mutationObject));
	create mutation observer

anObserver.observe(element, options);
	have to specify what to look for.
	can use the same observer for multiple elements
	if do observe twice with the same observer and element : remove all other observers ???
	the callback will now be called when a change is detected

options:
	childList		addition/removal of child nodes
	attributes		change to attributes
	characterData	change to character data (textnode)

	subtree
		observe change to all children
		(can register on a parent)
		for childList and characterData
	attributeFilter
		attributes to be monitored, others are ignored
		for attributes
		automatically sets attributes to true
	attributeOldValue
		have the old value
		automatically sets attributes to true
	characterDataOldValue
		have the previous value of the node's text
		automatically sets characterData to true

MutationRecord fields:
type
	'childList'
	'attributes'
	'characterData'
target
	(there is no currentTarget)
addedNodes
RemovedNodes
	for childList
previousSibling
nextSibling
	for childList
attributeName
	for attributes
oldValue
	for attribute/characterData

anObserver.disconnect()
	stop watching for modifications

anObserver.takeRecords()
	retrieves any pending modifications
	the callback won't get called for those records
	used before disconnect() to make sure we processed all the records



--- fetch ---
aResponse = await fetch(url, options);
	promise based
	reject : couldn't make the request, abnormal (header) response
		404 and the like do NOT cause a rejection
	response is the header only, not the data
	can also pass a Request object (contains the URL and options)

options {...}
method: 'POST'
body: theBody
	if the body is a string, a Content-Type is added automatically
headers: { Xxx: "value"}
	some headers are restricted
signal: anAbortController.signal
	abort the fetch, see AbortController
referrer
	"" no referrer
	"someURL" can set anyreferrer we want
referrerPolicy
	browser sends the referrer for us
	the referrer sent depends on the policy (a string)
	each policy may send a different value depending on :
		same origin, another origin, https->http
redirect
	behaviour when redirect
	"follow" (default)	automatically follow 
	"error"				error in case of redirect
	"manual"			our code checks and handles redirect itself
mode
	change CORS setting
	"cors" default, (attempts) cors request
	"same-origin" error if try a cross-origin request
	"no-cors" allow safe cross-origin request, cannot read result
				allows what has always been possible
				like img.src="cross origin url"
credentials
	"same-origin": default, only send credentials for same-origin
	"include" : send cookies even on cross-origin (must be allowed by the server)
	"omit" : never send cookie (same or cross origin)
cache
	fetch() uses HTTP-caching
	can change that behaviour
keepalive
	if true when closing the page
	instead of stopping the request
	the (small) request will be sent to the server
	won't handle response
	eg.: sending statistics.


response.status
	eg. 200
response.ok
	true if http status code 200-299
response.headers
	Map-like object
	get(xxx)
	iterate

response.body
	a ReadableStream : allows download chunk-by-chunk
	reader = response.body.getReader();
	while(true){
		{done, value} = await reader.read();
		if(done) break;
		//do something with value which is a Uint8Array (can be converted)
	}

response.text()
response.json()
response.blob()
..
	await on it
	can only call it once


-- Form data --
new FormData(aForm);
	can be the body of fetch
		fetch(url, {method: 'POST', body: aformData});

append(name, value)
	a form can have multiple fields with the same name
	append adds multiple same-named field
append(name, blob, fileName)
	as if <input type="file">
	cf Blob
set(name, value)
	does not allow multiple fields of the same name
	removes all existing fields with the same name before setting
delete(name)
get(name)
has(name)

for(let [name, value] of aFormData){}


-- AbortController --
used to abort async operations (eg. fetch)

let ac = new AbortController();
ac.abort();
ac.signal.addEventListener('abort', function(){console.log(arguments)});
signal.aborted == true/false

fetch(anURL, {signal: ac.signal});
	fetch has support for the AbortController



--- Same Origin Policy, Content Security Policy and CORS ---
Same Origin Policy
	restrict js from reading resources from another origin

CORS and image: can retrieve image from a cross-origin but cannot access its data from js
CORS and form: can send get/post form to cross-origin

origin is : domain/port/protocol (scheme/host/port)
subdomain considered a different domain
cross-origin if a difference in origin


Two mechanisms to protect:
- Content-Security-Policy
  prevent the page from loading/running some content that comes from a different origin(script, image,...)
  we prevent our own page from doing bad things (protects from XSS,..)
- CORS
  allows js to read from another origin (which is normally forbidden)
  client js attempts reading from another origin
  server can prevent read from unwanted origins

For both, the verification is made on the client (browser).
Prevents bad guys from tricking the browser of users from doing bad thing
Does not prevent bad guys from disabling those protections on their own machines



-- Content-Security-Policy --
specifies which domain the content can be loaded from
can also restrict protocol (eg. https only)
prevents XSS

http header or <meta>
response header:
Content-Security-Policy: default-src https://cdn.example.net; script-src 'self' https://api.mywebsite.com; img-src 'none'

<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src *; script-src https://*;">

by default allows everything

directive1 value; directive2 value1 value2
series of directives.
; separated
directive format: <directive-name> <value> [<value> ...]


directives
categories of directives : fetch, document, navigation, reporting, other

Fetch directives:
controls loading of ressources (xxx-src)
default-src
	fallback value for other fetch directives
	if another directive is explicitely set : value of default NOT used for that directive (erases does not add)

script-src
	inline script (<script>x</script>) //
		blocked by default even if 'self' or *
		needs 'unsafe-inline' to allow
	blocks eval by default
		the mere presence of script-src directive blocks eval(str)
		see unsafe-eval to enable

connect-src
	Allow fetch, XMLHttpReuest, WebSocket, Navigator.sendBeacon, <a> ping

font-src

frame-src

img-src

media-src
	<audio>, <video>, <track>

Document directives: 
base-uri
	urls that can be used for <base> head tag

Navigation directives:
form-action
	allow target of form submission

frame-ancestors
	determine who can embed this resource

Reporting directives:
send JSON somewhere whenever a policy blocks something



Values:
'none'
	don't allow any loading

'self'
	only from the current origin

'unsafe-inline'
	Allow scripts, onclick=,...

'unsafe-eval'
	Allow eval, and associated: function(str), setTimeout(str),..

'strict-dynamic'
	if use nonce/sha to allow a script (the standard way, outside of this value)
	then all scripts loaded by this sha/nonce-verifified script will be allowed
	not in safari

<hash-algo>-<base64-value>
eg. sha256-jzgBGA4UWFFmpOBq0JpdsySukE1FrEN5bUpoK8Z29fY=

nonce-xxx
	?

host source
localhost
	localhost port 80
localhost:5501
	localhost port 5501
https://localhost:5501
	..and https
https://localhost:5501/exercises/HTML/a.js
	full match
https://localhost:*
	any port

*.localhost
	any subdomain of localhost
	BUT not localhost itself!

*
	any source
	doesn't allow inline, still need to use 'unsafe-inline'


Content-Security-Policy-Report-Only
	Like Content-Security-Policy but only reports and does not enforce
	allow testing new policies without breaking a site



-- CORS --
Cross-Origin Resource Sharing
	is about allowing js to read from a server which is normally not possible
	= sharing resources between origins
	the goal was to allow cross-site AJAX

CORS does not allow/prevent making get/post requests to cross-origin servers
It has always been possible : <img src="external">, submit a form,...
It does not prevent CSRF.
It does prevent reading data from another origin.

two types of cross-origin requests:
- safe request
  only the methods :
  	GET/POST/HEAD
  only the headers :
  	Accept
  	Accept-Language
  	Content-Language
  	Content-Type
  		one of : application/x-www-form-urlencoded, multipart/form-data, text/plain
- unsafe requests
	all other requests

Why those specific requests considered safe?
Those are the requests that could be made by old browser/js
eg. using <form action="url"> or <script src="url">
Old webservers know that such requests can come from browser/javascript and take that into account 
Old webservers can mistakenly assume the request doesn't come from a browser if it an unsafe request and do something unsafe



1) same origin request:
no restriction


2) safe cross-origin requests
- Origin added to the header of the request : domain/protocol/port without path
	server checks this field and decide if it accept this cross-origin request

- server response:
Access-Control-Allow-Origin
	a domain/protocol/port (no path)
	or
	*
Access-Control-Expose-Headers
	allow js to read more than the safe headers (see below)
	eg.: Access-Control-Expose-Headers: Content-Length,API-Key
Access-Control-Allow-Credentials: true 
	for requests made with credentials (eg. for fetch credentials:"include")
	by default cross-origin requests do not include cookies
	both client and server must indicate they are ok sending cookies 
	if client sent with cookie but server didn't include this header => response won't be passed to js
	credential = cookie, Authorization http header, client certificate

js only allowed to read some "safe" response headers:
	Cache-Control
	Content-Language
	Content-Type
	Expires
	Last-Modified
	Pragma


3) unsafe cross-origin requests:
- before sending the request send a preflight request.
	used to avoid problem with old server that could assume that such a request cannot come from a browser and do something unsecure 

preflight request
	used to check if the server will accept our unsafe cross-origin request
	will it accept our origin/method/headers
the request:
	OPTIONS method 
	no body
	headers: 
		Access-Control-Request-Method
		Access-Control-Request-Headers
		Origin

- preflight server response:
empty body
status 200
headers:
	Access-Control-Allow-Origin
		* or an origin
	Access-Control-Allow-Methods
	Access-Control-Allow-Headers
	(Access-Control-Allow-Credentials: true)
	(Access-Control-Max-Age cache permissions to prevent too many preflights)
server typically do not just allow the requested method/headers but send all the allowed ones (to prevent another preflight)

- actual request
	Origin in the header

- actual response
	Access-Control-Allow-Origin in the header


-- credentials --
cross-origin js request does not include cookies by default.
fetch(url, {credentials: "include"});
if server accepts cookie it will add in the response header:
Access-Control-Allow-Credentials: true

Access-Control-Allow-Origin: * forbidden if use credentials



--- URL ---
Can use where url string expected (eg. fetch())
does the encoding for us (eg. " " => "%20)
new URL("https://javascript.info/profile")
	URL
new URL("profile", "https://javascript.info")
	URL with a base and a path
new URL("..", anURL);
	URL relative to another URL

new URL("https://the.host:81/path?search=value#hash");
                      href                         |
      origin           |        |             |    |
        |       host   |        |             |    |
protocol| hostname|port|pathname|search       |hash|
https: // the.host:81   /path    ?search=value #hash

url.href			the full thing
url.protocol		https:
url.hostname		the.host	(host but no port)
url.port			81
url.host			the.host:81 (hostname+port)
url.origin			https://the.host:81 (protocol+host)

url.pathname		/path
url.search			?search=value	(string)
url.searchParams	map-like object (get, set, has, delete)

encodeURI(anEntireURLString)
same as new URL(string).href
: ? = & # allowed in URL => not encoded
encodes characters totally forbidden in a URL
decodeURI

encodeURIComponent
encode individual pathname/search/hash (encodes ? = & +,...)
: ? = & # not allowed in URL => encoded
decodeURIComponent



--- WebSocket ---
bidirectional persistent connection

let socket = new WebSocket("ws://xxx")
let socket = new WebSocket("wss://xxx")
	wss is encrypted (like http vs https)


--- cookie ---
Set by server using HTTP header Set-Cookie
Browser adds them automatically to subsequent requests to the server

name=value; name2=value2
	representation of cookieS
	each pair is its own cookie
	format used by Set-Cookie, document.cookie
	space after ;
	4k max per cookie

document.cookie
	accessor property

str=document.cookie
	cookies as a single string

document.cookie="key=value"
	sets a single cookie! does not overwrite all cookies
	name and value must be encoded : encodeURIComponent
	document.cookie="k=v; k2=v2"
		k2 ignored (k2 interpreted as an option)

document.cookie="key=value; option=optionvalue; option2"
	can add options that will impact the cookie

document.cookie="k=v; path=/apath"
	cookie accessible under that path and subpaths
	an absolute path (/xxx not xxx) //
	default current path 
	path=/ sets the path to the root so the cookie is accessible from all pages
	a page in one path can access a cookie in another path : create iframe and access its cookie. (not the case with different domains)

document.cookie="k=v; domain=example.com"
	default: 	domain is the current domain (host)
				accessible on the domain NOT subdomain
	possible value:
		current domain
		parent domain			(allows cookie access to all subdomains)
		NO other domain			(on foo.com set cookie for bar.com)
		NO sibling domain		(on x.example.com set cookie for y.example.com)
		NO child subdomain		(on example.com set cookie for x.example.com)
	if set explicit domain : accessible to that domain and subdomains
	in the browser (dev tools):
		example.com => only the domain, no subdomain (set implicitely)
		.example.com => domain and subdomains (set explicitely)

document.cookie="k=v; max-age=amountinseconds"
document.cookie="k=v; expires=gmtstring"
	when will the browser delete the cookie
	if not set : cookie is a session cookie => expires at the end of the session
	expires: format of date.toUTCString
	

document.cookie="k=v; secure"
	cookie is only passed in request header if over https
	will only appear in document.cookie if we are on https
	(browser dev tools will show the cookie even if it isn't active)

document.cookie="k=v; samesite=xxx"
	should the cookie be sent when doing a cross site request
	can prefent CSRF attacks
	recent : not supported until 2018
	alternative : csrf token
document.cookie="k=v; samesite=strict"
	cookie is never sent across domain
	problem: if user click a link (eg. going to the homepage)
		=> cookie not sent: not logged in,...
	
document.cookie="k=v; samesite=lax"
	default value
	like strict (no cross-site) except if both conditions are met:
	- it's a safe meethod (GET, HEAD,..)
	- operation is "top-level navigation" : change page in the browser
		excludes : iframe, js request, img
	allows go to url operation to work
	
document.cookie="k=v; samesite=none"
	always send the cookie, including during cross-site requests

HttpOnly
	in Set-Cookie, not js
	cookie not visible in js
	preserves cookie against xss attacks

to delete a cookie
set max-age=-1
same path/domain !

document.cookie = `key=value; path=/; expires=${new Date("2025-01-01").toUTCString()}; secure; samesite=lax`
	can use cookie to store data
	but
		limited in size
		sent to server each time
		can be manipulated by the server


<img src="thirdparty.com/tracker">
	if Set-Cookie in response
	cookie set on thirdparty.com (not the current site)
	allows ad tracking (same cookie if visit other site containing the tracker=

<script src="thirdparty.com/tracker">
	document.cookie = xxx
	sets cookie on the current domain NOT thirdparty


--- localStorage sessionStorage---
save key-value pairs
a few Mb
localStorage
	shared within the same origin
	survive browser restart
	shared between tabs
sessionStorage
	survive page refresh
	not shared between tabs

same API
setItem(key, value)
getItem(key)
removeItem(key)
clear()
key(index)
length

key and value are strings only!
can use JSON

technically can set/get values directly through properties:
localStorage.key = "value";
	not recommended
		can be a clash with built-in properties
		(storage event (notifying ata modification) is not triggered)
			not true in firefox and chrome

not iterable but can use
for(let [key, value] of Object.entries(localStorage){}

window.onstorage
	triggers when localStorage is changed IN ANOTHER WINDOW
	event contains
		key
		newValue
		oldValueurl
	can be used to communicate across windows!
	although there is a dedicated API : broadcast channel (low support?)


reports of:
- firefox deleting localStorage
- safari not updating a localstorage changed in another tab

