???
Symbol "The symbol type is used to create unique identifiers for objects" https://javascript.info/types
weird comparison rules https://javascript.info/comparison

standard
last published:
https://www.ecma-international.org/publications/standards/Ecma-262.htm
includes proposals:
https://tc39.es/ecma262/
https://github.com/tc39/proposals

courses:
https://javascript.info/
https://developer.mozilla.org/en-US/docs/Web/JavaScript
https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/#basic-javascript
codeacademy
https://www.theodinproject.com/paths/foundations/courses/foundations
udemy
	ES2015	https://www.udemy.com/course/the-advanced-web-developer-bootcamp/
	ES6		https://www.udemy.com/course/modern-javascript-es6-for-react-js/
nodeschool

todo
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode


npm
npm install
-g
	install globally
-D
	devDependency (develop/stest)

npm init
	create project
-y --yes
	defaults, do not prompt questions


"use strict";
Introduced in EC5 (2009), backward incompatible changes
at beginning of script
at beginning of function
??? automatically enabled by modules and classes?

;
always ; recommended


==
	does type conversion
	if number + a string/boolean => the string/boolean converted to number
===
	no type conversion
	different type => different

typeof
	return string of the type

true/false	'boolean'
null		'object'	!
[]			'object'	!
{}			'object'
function(){}	'function'
() => none	'function'
class Foo{}	'function'
1			'number'
1n			'bigint'
Symbol("a")	'symbol


null
	no value, unknown, empty
	x = null; makes sense
	Number(null) === 0

undefined
	value not assigned
	x = undefined; to avoid
	Number(undefined) === NaN

null == undefined
	this is a special rule
	(eg. [] != {})

Number
numbers are double
0.1 + 0.2 == 0.30000000000000004
Number.MIN_SAFE_INTEGER
Number.MAX_SAFE_INTEGER
	around 10**15, 2^53-1
	Number.MAX_SAFE_INTEGER +1 === Number.MAX_SAFE_INTEGER + 2

Infinity

BigInt
	represents integer of any size
	BigInt(1)
	BigInt("1")
	1n 				// BigInt literal
	BigInt(1) + 1	// NO
	BigInt(1) == 1	// yes (also <, <=,...)
	BigInt(1) === 1 // false
	
	can use * + / ...
	/ rounds toward zero
	cannot use with Math.xxx





"13"[0] === "1"
"13".charAt(0) === "1"
"oh hello".substr(3, 4)		// from, length
"oh hello".substring(3, 7)  // from, to (excluded)
"hell".length === 4




var x = 0;
var x = 0, y = 1;
	set variable
	block scope (visible in the rest of the function)
var x;
	var has the value undefined
	different from x not being defined

x = 0;
	global var




['hi', 1, true]
push(elem);
	add to the right
unshift(first)
	add to the left
pop()
	remove last
shift()
	remove first
.length
[1, "hi"].join(", ");
	"1, hi"
slice(from_i, [to_i])
	returns new subarray with elements
	does not modify the array
splice(start, deleteCount, item1, item2, itemN)
	-remove items
	-remove and add items
	-add items (deleteCount = 0)
	in place
	returns removed elements
	


{key:0, "k":0}
	create an object
	key : string or identifier
	looks like a dictionary but isn't : 
		default keys
		keys are string only
		no size
	use new Map() for a real dictionary type
a.key
a["key"]
	get value of key


m = new Map();
m.set("x");


if(x){
    console.log("yup");
}else if(true) {
    console.log("nope");
}else{
    console.log("nope")
}

v = 'a';
switch(v){
    case 'a':
        console.log("this is a");
        break;
    case 'A':
        console.log("this is A");
        break;
    default:
        console.log("other");
        break;
}


while(x > 0) {...}
do { ... } while(x > 0)

outer: for(var i = 0; i < 10; i++) {
    for(var j = 0; j < 3 ; j++) {
        console.log(i, j);
        break outer;
    }
}
	can break of outer loop by giving a label

for(var x = 0; x < 2; x++){};
for(var x in obj){};
	enumerable property names of objects
	included enumerable inherited properties
	iterate on
		object	(x are the Enumerable keys)
		array	(prefer the use or..of)
		Map		(prefer the use of for..of)
		NOT string (works but keys: 0, 1, 2,... prefer the use of for..of)
	it's a weird choice to enumerator object (outside debugging?)
	often use for..of
for(var x of iterable){};
	iterate on iterable objects
	iterable[Symbol.iterator] magic behind the scene
	iterate on
		array
		string
		Map
		Set
		NodeList (document.querySelectorAll)
		Object.entries/keys/values(an_object) to iterate over objects
forEach
a.forEach(elem => console.log(elem));
a.forEach((elem, index) => console.log(elem, index));
a.forEach((elem, index, array) => console.log(elem, index, array));
	for arrays



(function(){
    //...
})();
	IIFE
	Immediately Invoked Function Expression


